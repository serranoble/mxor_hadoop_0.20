/**
 * Autogenerated by Thrift
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 */
package org.apache.hadoop.thriftfs.api;

import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.util.HashMap;
import java.util.Set;
import java.util.HashSet;
import java.util.Collections;
import org.apache.log4j.Logger;

import org.apache.thrift.*;
import org.apache.thrift.meta_data.*;
import org.apache.thrift.protocol.*;

public class ThriftHadoopFileSystem {

  public interface Iface {

    public void setInactivityTimeoutPeriod(long periodInSeconds) throws TException;

    public void shutdown(int status) throws TException;

    public ThriftHandle create(Pathname path) throws ThriftIOException, TException;

    public ThriftHandle createFile(Pathname path, short mode, boolean overwrite, int bufferSize, short block_replication, long blocksize) throws ThriftIOException, TException;

    public ThriftHandle open(Pathname path) throws ThriftIOException, TException;

    public ThriftHandle append(Pathname path) throws ThriftIOException, TException;

    public boolean write(ThriftHandle handle, String data) throws ThriftIOException, TException;

    public String read(ThriftHandle handle, long offset, int size) throws ThriftIOException, TException;

    public boolean close(ThriftHandle out) throws ThriftIOException, TException;

    public boolean rm(Pathname path, boolean recursive) throws ThriftIOException, TException;

    public boolean rename(Pathname path, Pathname dest) throws ThriftIOException, TException;

    public boolean mkdirs(Pathname path) throws ThriftIOException, TException;

    public boolean exists(Pathname path) throws ThriftIOException, TException;

    public FileStatus stat(Pathname path) throws ThriftIOException, TException;

    public List<FileStatus> listStatus(Pathname path) throws ThriftIOException, TException;

    public void chmod(Pathname path, short mode) throws ThriftIOException, TException;

    public void chown(Pathname path, String owner, String group) throws ThriftIOException, TException;

    public void setReplication(Pathname path, short replication) throws ThriftIOException, TException;

    public List<BlockLocation> getFileBlockLocations(Pathname path, long start, long length) throws ThriftIOException, TException;

  }

  public static class Client implements Iface {
    public Client(TProtocol prot)
    {
      this(prot, prot);
    }

    public Client(TProtocol iprot, TProtocol oprot)
    {
      iprot_ = iprot;
      oprot_ = oprot;
    }

    protected TProtocol iprot_;
    protected TProtocol oprot_;

    protected int seqid_;

    public TProtocol getInputProtocol()
    {
      return this.iprot_;
    }

    public TProtocol getOutputProtocol()
    {
      return this.oprot_;
    }

    public void setInactivityTimeoutPeriod(long periodInSeconds) throws TException
    {
      send_setInactivityTimeoutPeriod(periodInSeconds);
      recv_setInactivityTimeoutPeriod();
    }

    public void send_setInactivityTimeoutPeriod(long periodInSeconds) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("setInactivityTimeoutPeriod", TMessageType.CALL, seqid_));
      setInactivityTimeoutPeriod_args args = new setInactivityTimeoutPeriod_args();
      args.periodInSeconds = periodInSeconds;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public void recv_setInactivityTimeoutPeriod() throws TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      setInactivityTimeoutPeriod_result result = new setInactivityTimeoutPeriod_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      return;
    }

    public void shutdown(int status) throws TException
    {
      send_shutdown(status);
      recv_shutdown();
    }

    public void send_shutdown(int status) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("shutdown", TMessageType.CALL, seqid_));
      shutdown_args args = new shutdown_args();
      args.status = status;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public void recv_shutdown() throws TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      shutdown_result result = new shutdown_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      return;
    }

    public ThriftHandle create(Pathname path) throws ThriftIOException, TException
    {
      send_create(path);
      return recv_create();
    }

    public void send_create(Pathname path) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("create", TMessageType.CALL, seqid_));
      create_args args = new create_args();
      args.path = path;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public ThriftHandle recv_create() throws ThriftIOException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      create_result result = new create_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.ouch != null) {
        throw result.ouch;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "create failed: unknown result");
    }

    public ThriftHandle createFile(Pathname path, short mode, boolean overwrite, int bufferSize, short block_replication, long blocksize) throws ThriftIOException, TException
    {
      send_createFile(path, mode, overwrite, bufferSize, block_replication, blocksize);
      return recv_createFile();
    }

    public void send_createFile(Pathname path, short mode, boolean overwrite, int bufferSize, short block_replication, long blocksize) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("createFile", TMessageType.CALL, seqid_));
      createFile_args args = new createFile_args();
      args.path = path;
      args.mode = mode;
      args.overwrite = overwrite;
      args.bufferSize = bufferSize;
      args.block_replication = block_replication;
      args.blocksize = blocksize;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public ThriftHandle recv_createFile() throws ThriftIOException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      createFile_result result = new createFile_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.ouch != null) {
        throw result.ouch;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "createFile failed: unknown result");
    }

    public ThriftHandle open(Pathname path) throws ThriftIOException, TException
    {
      send_open(path);
      return recv_open();
    }

    public void send_open(Pathname path) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("open", TMessageType.CALL, seqid_));
      open_args args = new open_args();
      args.path = path;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public ThriftHandle recv_open() throws ThriftIOException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      open_result result = new open_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.ouch != null) {
        throw result.ouch;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "open failed: unknown result");
    }

    public ThriftHandle append(Pathname path) throws ThriftIOException, TException
    {
      send_append(path);
      return recv_append();
    }

    public void send_append(Pathname path) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("append", TMessageType.CALL, seqid_));
      append_args args = new append_args();
      args.path = path;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public ThriftHandle recv_append() throws ThriftIOException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      append_result result = new append_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.ouch != null) {
        throw result.ouch;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "append failed: unknown result");
    }

    public boolean write(ThriftHandle handle, String data) throws ThriftIOException, TException
    {
      send_write(handle, data);
      return recv_write();
    }

    public void send_write(ThriftHandle handle, String data) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("write", TMessageType.CALL, seqid_));
      write_args args = new write_args();
      args.handle = handle;
      args.data = data;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public boolean recv_write() throws ThriftIOException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      write_result result = new write_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.ouch != null) {
        throw result.ouch;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "write failed: unknown result");
    }

    public String read(ThriftHandle handle, long offset, int size) throws ThriftIOException, TException
    {
      send_read(handle, offset, size);
      return recv_read();
    }

    public void send_read(ThriftHandle handle, long offset, int size) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("read", TMessageType.CALL, seqid_));
      read_args args = new read_args();
      args.handle = handle;
      args.offset = offset;
      args.size = size;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public String recv_read() throws ThriftIOException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      read_result result = new read_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.ouch != null) {
        throw result.ouch;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "read failed: unknown result");
    }

    public boolean close(ThriftHandle out) throws ThriftIOException, TException
    {
      send_close(out);
      return recv_close();
    }

    public void send_close(ThriftHandle out) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("close", TMessageType.CALL, seqid_));
      close_args args = new close_args();
      args.out = out;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public boolean recv_close() throws ThriftIOException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      close_result result = new close_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.ouch != null) {
        throw result.ouch;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "close failed: unknown result");
    }

    public boolean rm(Pathname path, boolean recursive) throws ThriftIOException, TException
    {
      send_rm(path, recursive);
      return recv_rm();
    }

    public void send_rm(Pathname path, boolean recursive) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("rm", TMessageType.CALL, seqid_));
      rm_args args = new rm_args();
      args.path = path;
      args.recursive = recursive;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public boolean recv_rm() throws ThriftIOException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      rm_result result = new rm_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.ouch != null) {
        throw result.ouch;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "rm failed: unknown result");
    }

    public boolean rename(Pathname path, Pathname dest) throws ThriftIOException, TException
    {
      send_rename(path, dest);
      return recv_rename();
    }

    public void send_rename(Pathname path, Pathname dest) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("rename", TMessageType.CALL, seqid_));
      rename_args args = new rename_args();
      args.path = path;
      args.dest = dest;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public boolean recv_rename() throws ThriftIOException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      rename_result result = new rename_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.ouch != null) {
        throw result.ouch;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "rename failed: unknown result");
    }

    public boolean mkdirs(Pathname path) throws ThriftIOException, TException
    {
      send_mkdirs(path);
      return recv_mkdirs();
    }

    public void send_mkdirs(Pathname path) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("mkdirs", TMessageType.CALL, seqid_));
      mkdirs_args args = new mkdirs_args();
      args.path = path;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public boolean recv_mkdirs() throws ThriftIOException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      mkdirs_result result = new mkdirs_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.ouch != null) {
        throw result.ouch;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "mkdirs failed: unknown result");
    }

    public boolean exists(Pathname path) throws ThriftIOException, TException
    {
      send_exists(path);
      return recv_exists();
    }

    public void send_exists(Pathname path) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("exists", TMessageType.CALL, seqid_));
      exists_args args = new exists_args();
      args.path = path;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public boolean recv_exists() throws ThriftIOException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      exists_result result = new exists_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.ouch != null) {
        throw result.ouch;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "exists failed: unknown result");
    }

    public FileStatus stat(Pathname path) throws ThriftIOException, TException
    {
      send_stat(path);
      return recv_stat();
    }

    public void send_stat(Pathname path) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("stat", TMessageType.CALL, seqid_));
      stat_args args = new stat_args();
      args.path = path;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public FileStatus recv_stat() throws ThriftIOException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      stat_result result = new stat_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.ouch != null) {
        throw result.ouch;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "stat failed: unknown result");
    }

    public List<FileStatus> listStatus(Pathname path) throws ThriftIOException, TException
    {
      send_listStatus(path);
      return recv_listStatus();
    }

    public void send_listStatus(Pathname path) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("listStatus", TMessageType.CALL, seqid_));
      listStatus_args args = new listStatus_args();
      args.path = path;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public List<FileStatus> recv_listStatus() throws ThriftIOException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      listStatus_result result = new listStatus_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.ouch != null) {
        throw result.ouch;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "listStatus failed: unknown result");
    }

    public void chmod(Pathname path, short mode) throws ThriftIOException, TException
    {
      send_chmod(path, mode);
      recv_chmod();
    }

    public void send_chmod(Pathname path, short mode) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("chmod", TMessageType.CALL, seqid_));
      chmod_args args = new chmod_args();
      args.path = path;
      args.mode = mode;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public void recv_chmod() throws ThriftIOException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      chmod_result result = new chmod_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.ouch != null) {
        throw result.ouch;
      }
      return;
    }

    public void chown(Pathname path, String owner, String group) throws ThriftIOException, TException
    {
      send_chown(path, owner, group);
      recv_chown();
    }

    public void send_chown(Pathname path, String owner, String group) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("chown", TMessageType.CALL, seqid_));
      chown_args args = new chown_args();
      args.path = path;
      args.owner = owner;
      args.group = group;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public void recv_chown() throws ThriftIOException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      chown_result result = new chown_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.ouch != null) {
        throw result.ouch;
      }
      return;
    }

    public void setReplication(Pathname path, short replication) throws ThriftIOException, TException
    {
      send_setReplication(path, replication);
      recv_setReplication();
    }

    public void send_setReplication(Pathname path, short replication) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("setReplication", TMessageType.CALL, seqid_));
      setReplication_args args = new setReplication_args();
      args.path = path;
      args.replication = replication;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public void recv_setReplication() throws ThriftIOException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      setReplication_result result = new setReplication_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.ouch != null) {
        throw result.ouch;
      }
      return;
    }

    public List<BlockLocation> getFileBlockLocations(Pathname path, long start, long length) throws ThriftIOException, TException
    {
      send_getFileBlockLocations(path, start, length);
      return recv_getFileBlockLocations();
    }

    public void send_getFileBlockLocations(Pathname path, long start, long length) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("getFileBlockLocations", TMessageType.CALL, seqid_));
      getFileBlockLocations_args args = new getFileBlockLocations_args();
      args.path = path;
      args.start = start;
      args.length = length;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public List<BlockLocation> recv_getFileBlockLocations() throws ThriftIOException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      getFileBlockLocations_result result = new getFileBlockLocations_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.ouch != null) {
        throw result.ouch;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "getFileBlockLocations failed: unknown result");
    }

  }
  public static class Processor implements TProcessor {
    private static final Logger LOGGER = Logger.getLogger(Processor.class.getName());
    public Processor(Iface iface)
    {
      iface_ = iface;
      processMap_.put("setInactivityTimeoutPeriod", new setInactivityTimeoutPeriod());
      processMap_.put("shutdown", new shutdown());
      processMap_.put("create", new create());
      processMap_.put("createFile", new createFile());
      processMap_.put("open", new open());
      processMap_.put("append", new append());
      processMap_.put("write", new write());
      processMap_.put("read", new read());
      processMap_.put("close", new close());
      processMap_.put("rm", new rm());
      processMap_.put("rename", new rename());
      processMap_.put("mkdirs", new mkdirs());
      processMap_.put("exists", new exists());
      processMap_.put("stat", new stat());
      processMap_.put("listStatus", new listStatus());
      processMap_.put("chmod", new chmod());
      processMap_.put("chown", new chown());
      processMap_.put("setReplication", new setReplication());
      processMap_.put("getFileBlockLocations", new getFileBlockLocations());
    }

    protected static interface ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException;
    }

    private Iface iface_;
    protected final HashMap<String,ProcessFunction> processMap_ = new HashMap<String,ProcessFunction>();

    public boolean process(TProtocol iprot, TProtocol oprot) throws TException
    {
      TMessage msg = iprot.readMessageBegin();
      ProcessFunction fn = processMap_.get(msg.name);
      if (fn == null) {
        TProtocolUtil.skip(iprot, TType.STRUCT);
        iprot.readMessageEnd();
        TApplicationException x = new TApplicationException(TApplicationException.UNKNOWN_METHOD, "Invalid method name: '"+msg.name+"'");
        oprot.writeMessageBegin(new TMessage(msg.name, TMessageType.EXCEPTION, msg.seqid));
        x.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        return true;
      }
      fn.process(msg.seqid, iprot, oprot);
      return true;
    }

    private class setInactivityTimeoutPeriod implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        setInactivityTimeoutPeriod_args args = new setInactivityTimeoutPeriod_args();
        args.read(iprot);
        iprot.readMessageEnd();
        setInactivityTimeoutPeriod_result result = new setInactivityTimeoutPeriod_result();
        iface_.setInactivityTimeoutPeriod(args.periodInSeconds);
        oprot.writeMessageBegin(new TMessage("setInactivityTimeoutPeriod", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class shutdown implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        shutdown_args args = new shutdown_args();
        args.read(iprot);
        iprot.readMessageEnd();
        shutdown_result result = new shutdown_result();
        iface_.shutdown(args.status);
        oprot.writeMessageBegin(new TMessage("shutdown", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class create implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        create_args args = new create_args();
        args.read(iprot);
        iprot.readMessageEnd();
        create_result result = new create_result();
        try {
          result.success = iface_.create(args.path);
        } catch (ThriftIOException ouch) {
          result.ouch = ouch;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing create", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing create");
          oprot.writeMessageBegin(new TMessage("create", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("create", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class createFile implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        createFile_args args = new createFile_args();
        args.read(iprot);
        iprot.readMessageEnd();
        createFile_result result = new createFile_result();
        try {
          result.success = iface_.createFile(args.path, args.mode, args.overwrite, args.bufferSize, args.block_replication, args.blocksize);
        } catch (ThriftIOException ouch) {
          result.ouch = ouch;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing createFile", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing createFile");
          oprot.writeMessageBegin(new TMessage("createFile", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("createFile", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class open implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        open_args args = new open_args();
        args.read(iprot);
        iprot.readMessageEnd();
        open_result result = new open_result();
        try {
          result.success = iface_.open(args.path);
        } catch (ThriftIOException ouch) {
          result.ouch = ouch;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing open", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing open");
          oprot.writeMessageBegin(new TMessage("open", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("open", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class append implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        append_args args = new append_args();
        args.read(iprot);
        iprot.readMessageEnd();
        append_result result = new append_result();
        try {
          result.success = iface_.append(args.path);
        } catch (ThriftIOException ouch) {
          result.ouch = ouch;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing append", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing append");
          oprot.writeMessageBegin(new TMessage("append", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("append", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class write implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        write_args args = new write_args();
        args.read(iprot);
        iprot.readMessageEnd();
        write_result result = new write_result();
        try {
          result.success = iface_.write(args.handle, args.data);
          result.__isset.success = true;
        } catch (ThriftIOException ouch) {
          result.ouch = ouch;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing write", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing write");
          oprot.writeMessageBegin(new TMessage("write", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("write", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class read implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        read_args args = new read_args();
        args.read(iprot);
        iprot.readMessageEnd();
        read_result result = new read_result();
        try {
          result.success = iface_.read(args.handle, args.offset, args.size);
        } catch (ThriftIOException ouch) {
          result.ouch = ouch;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing read", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing read");
          oprot.writeMessageBegin(new TMessage("read", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("read", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class close implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        close_args args = new close_args();
        args.read(iprot);
        iprot.readMessageEnd();
        close_result result = new close_result();
        try {
          result.success = iface_.close(args.out);
          result.__isset.success = true;
        } catch (ThriftIOException ouch) {
          result.ouch = ouch;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing close", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing close");
          oprot.writeMessageBegin(new TMessage("close", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("close", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class rm implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        rm_args args = new rm_args();
        args.read(iprot);
        iprot.readMessageEnd();
        rm_result result = new rm_result();
        try {
          result.success = iface_.rm(args.path, args.recursive);
          result.__isset.success = true;
        } catch (ThriftIOException ouch) {
          result.ouch = ouch;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing rm", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing rm");
          oprot.writeMessageBegin(new TMessage("rm", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("rm", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class rename implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        rename_args args = new rename_args();
        args.read(iprot);
        iprot.readMessageEnd();
        rename_result result = new rename_result();
        try {
          result.success = iface_.rename(args.path, args.dest);
          result.__isset.success = true;
        } catch (ThriftIOException ouch) {
          result.ouch = ouch;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing rename", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing rename");
          oprot.writeMessageBegin(new TMessage("rename", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("rename", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class mkdirs implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        mkdirs_args args = new mkdirs_args();
        args.read(iprot);
        iprot.readMessageEnd();
        mkdirs_result result = new mkdirs_result();
        try {
          result.success = iface_.mkdirs(args.path);
          result.__isset.success = true;
        } catch (ThriftIOException ouch) {
          result.ouch = ouch;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing mkdirs", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing mkdirs");
          oprot.writeMessageBegin(new TMessage("mkdirs", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("mkdirs", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class exists implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        exists_args args = new exists_args();
        args.read(iprot);
        iprot.readMessageEnd();
        exists_result result = new exists_result();
        try {
          result.success = iface_.exists(args.path);
          result.__isset.success = true;
        } catch (ThriftIOException ouch) {
          result.ouch = ouch;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing exists", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing exists");
          oprot.writeMessageBegin(new TMessage("exists", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("exists", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class stat implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        stat_args args = new stat_args();
        args.read(iprot);
        iprot.readMessageEnd();
        stat_result result = new stat_result();
        try {
          result.success = iface_.stat(args.path);
        } catch (ThriftIOException ouch) {
          result.ouch = ouch;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing stat", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing stat");
          oprot.writeMessageBegin(new TMessage("stat", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("stat", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class listStatus implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        listStatus_args args = new listStatus_args();
        args.read(iprot);
        iprot.readMessageEnd();
        listStatus_result result = new listStatus_result();
        try {
          result.success = iface_.listStatus(args.path);
        } catch (ThriftIOException ouch) {
          result.ouch = ouch;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing listStatus", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing listStatus");
          oprot.writeMessageBegin(new TMessage("listStatus", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("listStatus", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class chmod implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        chmod_args args = new chmod_args();
        args.read(iprot);
        iprot.readMessageEnd();
        chmod_result result = new chmod_result();
        try {
          iface_.chmod(args.path, args.mode);
        } catch (ThriftIOException ouch) {
          result.ouch = ouch;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing chmod", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing chmod");
          oprot.writeMessageBegin(new TMessage("chmod", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("chmod", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class chown implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        chown_args args = new chown_args();
        args.read(iprot);
        iprot.readMessageEnd();
        chown_result result = new chown_result();
        try {
          iface_.chown(args.path, args.owner, args.group);
        } catch (ThriftIOException ouch) {
          result.ouch = ouch;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing chown", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing chown");
          oprot.writeMessageBegin(new TMessage("chown", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("chown", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class setReplication implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        setReplication_args args = new setReplication_args();
        args.read(iprot);
        iprot.readMessageEnd();
        setReplication_result result = new setReplication_result();
        try {
          iface_.setReplication(args.path, args.replication);
        } catch (ThriftIOException ouch) {
          result.ouch = ouch;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing setReplication", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing setReplication");
          oprot.writeMessageBegin(new TMessage("setReplication", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("setReplication", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class getFileBlockLocations implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        getFileBlockLocations_args args = new getFileBlockLocations_args();
        args.read(iprot);
        iprot.readMessageEnd();
        getFileBlockLocations_result result = new getFileBlockLocations_result();
        try {
          result.success = iface_.getFileBlockLocations(args.path, args.start, args.length);
        } catch (ThriftIOException ouch) {
          result.ouch = ouch;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing getFileBlockLocations", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing getFileBlockLocations");
          oprot.writeMessageBegin(new TMessage("getFileBlockLocations", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("getFileBlockLocations", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

  }

  public static class setInactivityTimeoutPeriod_args implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("setInactivityTimeoutPeriod_args");
    private static final TField PERIOD_IN_SECONDS_FIELD_DESC = new TField("periodInSeconds", TType.I64, (short)1);

    public long periodInSeconds;
    public static final int PERIODINSECONDS = 1;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
      public boolean periodInSeconds = false;
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(PERIODINSECONDS, new FieldMetaData("periodInSeconds", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.I64)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(setInactivityTimeoutPeriod_args.class, metaDataMap);
    }

    public setInactivityTimeoutPeriod_args() {
    }

    public setInactivityTimeoutPeriod_args(
      long periodInSeconds)
    {
      this();
      this.periodInSeconds = periodInSeconds;
      this.__isset.periodInSeconds = true;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public setInactivityTimeoutPeriod_args(setInactivityTimeoutPeriod_args other) {
      __isset.periodInSeconds = other.__isset.periodInSeconds;
      this.periodInSeconds = other.periodInSeconds;
    }

    @Override
    public setInactivityTimeoutPeriod_args clone() {
      return new setInactivityTimeoutPeriod_args(this);
    }

    public long getPeriodInSeconds() {
      return this.periodInSeconds;
    }

    public void setPeriodInSeconds(long periodInSeconds) {
      this.periodInSeconds = periodInSeconds;
      this.__isset.periodInSeconds = true;
    }

    public void unsetPeriodInSeconds() {
      this.__isset.periodInSeconds = false;
    }

    // Returns true if field periodInSeconds is set (has been asigned a value) and false otherwise
    public boolean isSetPeriodInSeconds() {
      return this.__isset.periodInSeconds;
    }

    public void setPeriodInSecondsIsSet(boolean value) {
      this.__isset.periodInSeconds = value;
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case PERIODINSECONDS:
        if (value == null) {
          unsetPeriodInSeconds();
        } else {
          setPeriodInSeconds((Long)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case PERIODINSECONDS:
        return new Long(getPeriodInSeconds());

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case PERIODINSECONDS:
        return isSetPeriodInSeconds();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof setInactivityTimeoutPeriod_args)
        return this.equals((setInactivityTimeoutPeriod_args)that);
      return false;
    }

    public boolean equals(setInactivityTimeoutPeriod_args that) {
      if (that == null)
        return false;

      boolean this_present_periodInSeconds = true;
      boolean that_present_periodInSeconds = true;
      if (this_present_periodInSeconds || that_present_periodInSeconds) {
        if (!(this_present_periodInSeconds && that_present_periodInSeconds))
          return false;
        if (this.periodInSeconds != that.periodInSeconds)
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case PERIODINSECONDS:
            if (field.type == TType.I64) {
              this.periodInSeconds = iprot.readI64();
              this.__isset.periodInSeconds = true;
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      oprot.writeFieldBegin(PERIOD_IN_SECONDS_FIELD_DESC);
      oprot.writeI64(this.periodInSeconds);
      oprot.writeFieldEnd();
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("setInactivityTimeoutPeriod_args(");
      boolean first = true;

      sb.append("periodInSeconds:");
      sb.append(this.periodInSeconds);
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class setInactivityTimeoutPeriod_result implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("setInactivityTimeoutPeriod_result");

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
    }});

    static {
      FieldMetaData.addStructMetaDataMap(setInactivityTimeoutPeriod_result.class, metaDataMap);
    }

    public setInactivityTimeoutPeriod_result() {
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public setInactivityTimeoutPeriod_result(setInactivityTimeoutPeriod_result other) {
    }

    @Override
    public setInactivityTimeoutPeriod_result clone() {
      return new setInactivityTimeoutPeriod_result(this);
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof setInactivityTimeoutPeriod_result)
        return this.equals((setInactivityTimeoutPeriod_result)that);
      return false;
    }

    public boolean equals(setInactivityTimeoutPeriod_result that) {
      if (that == null)
        return false;

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("setInactivityTimeoutPeriod_result(");
      boolean first = true;

      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class shutdown_args implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("shutdown_args");
    private static final TField STATUS_FIELD_DESC = new TField("status", TType.I32, (short)1);

    public int status;
    public static final int STATUS = 1;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
      public boolean status = false;
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(STATUS, new FieldMetaData("status", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.I32)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(shutdown_args.class, metaDataMap);
    }

    public shutdown_args() {
    }

    public shutdown_args(
      int status)
    {
      this();
      this.status = status;
      this.__isset.status = true;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public shutdown_args(shutdown_args other) {
      __isset.status = other.__isset.status;
      this.status = other.status;
    }

    @Override
    public shutdown_args clone() {
      return new shutdown_args(this);
    }

    public int getStatus() {
      return this.status;
    }

    public void setStatus(int status) {
      this.status = status;
      this.__isset.status = true;
    }

    public void unsetStatus() {
      this.__isset.status = false;
    }

    // Returns true if field status is set (has been asigned a value) and false otherwise
    public boolean isSetStatus() {
      return this.__isset.status;
    }

    public void setStatusIsSet(boolean value) {
      this.__isset.status = value;
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case STATUS:
        if (value == null) {
          unsetStatus();
        } else {
          setStatus((Integer)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case STATUS:
        return new Integer(getStatus());

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case STATUS:
        return isSetStatus();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof shutdown_args)
        return this.equals((shutdown_args)that);
      return false;
    }

    public boolean equals(shutdown_args that) {
      if (that == null)
        return false;

      boolean this_present_status = true;
      boolean that_present_status = true;
      if (this_present_status || that_present_status) {
        if (!(this_present_status && that_present_status))
          return false;
        if (this.status != that.status)
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case STATUS:
            if (field.type == TType.I32) {
              this.status = iprot.readI32();
              this.__isset.status = true;
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      oprot.writeFieldBegin(STATUS_FIELD_DESC);
      oprot.writeI32(this.status);
      oprot.writeFieldEnd();
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("shutdown_args(");
      boolean first = true;

      sb.append("status:");
      sb.append(this.status);
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class shutdown_result implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("shutdown_result");

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
    }});

    static {
      FieldMetaData.addStructMetaDataMap(shutdown_result.class, metaDataMap);
    }

    public shutdown_result() {
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public shutdown_result(shutdown_result other) {
    }

    @Override
    public shutdown_result clone() {
      return new shutdown_result(this);
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof shutdown_result)
        return this.equals((shutdown_result)that);
      return false;
    }

    public boolean equals(shutdown_result that) {
      if (that == null)
        return false;

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("shutdown_result(");
      boolean first = true;

      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class create_args implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("create_args");
    private static final TField PATH_FIELD_DESC = new TField("path", TType.STRUCT, (short)1);

    public Pathname path;
    public static final int PATH = 1;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(PATH, new FieldMetaData("path", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, Pathname.class)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(create_args.class, metaDataMap);
    }

    public create_args() {
    }

    public create_args(
      Pathname path)
    {
      this();
      this.path = path;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public create_args(create_args other) {
      if (other.isSetPath()) {
        this.path = new Pathname(other.path);
      }
    }

    @Override
    public create_args clone() {
      return new create_args(this);
    }

    public Pathname getPath() {
      return this.path;
    }

    public void setPath(Pathname path) {
      this.path = path;
    }

    public void unsetPath() {
      this.path = null;
    }

    // Returns true if field path is set (has been asigned a value) and false otherwise
    public boolean isSetPath() {
      return this.path != null;
    }

    public void setPathIsSet(boolean value) {
      if (!value) {
        this.path = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case PATH:
        if (value == null) {
          unsetPath();
        } else {
          setPath((Pathname)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case PATH:
        return getPath();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case PATH:
        return isSetPath();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof create_args)
        return this.equals((create_args)that);
      return false;
    }

    public boolean equals(create_args that) {
      if (that == null)
        return false;

      boolean this_present_path = true && this.isSetPath();
      boolean that_present_path = true && that.isSetPath();
      if (this_present_path || that_present_path) {
        if (!(this_present_path && that_present_path))
          return false;
        if (!this.path.equals(that.path))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case PATH:
            if (field.type == TType.STRUCT) {
              this.path = new Pathname();
              this.path.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.path != null) {
        oprot.writeFieldBegin(PATH_FIELD_DESC);
        this.path.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("create_args(");
      boolean first = true;

      sb.append("path:");
      if (this.path == null) {
        sb.append("null");
      } else {
        sb.append(this.path);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class create_result implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("create_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);
    private static final TField OUCH_FIELD_DESC = new TField("ouch", TType.STRUCT, (short)1);

    public ThriftHandle success;
    public static final int SUCCESS = 0;
    public ThriftIOException ouch;
    public static final int OUCH = 1;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ThriftHandle.class)));
      put(OUCH, new FieldMetaData("ouch", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(create_result.class, metaDataMap);
    }

    public create_result() {
    }

    public create_result(
      ThriftHandle success,
      ThriftIOException ouch)
    {
      this();
      this.success = success;
      this.ouch = ouch;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public create_result(create_result other) {
      if (other.isSetSuccess()) {
        this.success = new ThriftHandle(other.success);
      }
      if (other.isSetOuch()) {
        this.ouch = new ThriftIOException(other.ouch);
      }
    }

    @Override
    public create_result clone() {
      return new create_result(this);
    }

    public ThriftHandle getSuccess() {
      return this.success;
    }

    public void setSuccess(ThriftHandle success) {
      this.success = success;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been asigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public ThriftIOException getOuch() {
      return this.ouch;
    }

    public void setOuch(ThriftIOException ouch) {
      this.ouch = ouch;
    }

    public void unsetOuch() {
      this.ouch = null;
    }

    // Returns true if field ouch is set (has been asigned a value) and false otherwise
    public boolean isSetOuch() {
      return this.ouch != null;
    }

    public void setOuchIsSet(boolean value) {
      if (!value) {
        this.ouch = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((ThriftHandle)value);
        }
        break;

      case OUCH:
        if (value == null) {
          unsetOuch();
        } else {
          setOuch((ThriftIOException)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      case OUCH:
        return getOuch();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case OUCH:
        return isSetOuch();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof create_result)
        return this.equals((create_result)that);
      return false;
    }

    public boolean equals(create_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      boolean this_present_ouch = true && this.isSetOuch();
      boolean that_present_ouch = true && that.isSetOuch();
      if (this_present_ouch || that_present_ouch) {
        if (!(this_present_ouch && that_present_ouch))
          return false;
        if (!this.ouch.equals(that.ouch))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case SUCCESS:
            if (field.type == TType.STRUCT) {
              this.success = new ThriftHandle();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case OUCH:
            if (field.type == TType.STRUCT) {
              this.ouch = new ThriftIOException();
              this.ouch.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      } else if (this.isSetOuch()) {
        oprot.writeFieldBegin(OUCH_FIELD_DESC);
        this.ouch.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("create_result(");
      boolean first = true;

      sb.append("success:");
      if (this.success == null) {
        sb.append("null");
      } else {
        sb.append(this.success);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("ouch:");
      if (this.ouch == null) {
        sb.append("null");
      } else {
        sb.append(this.ouch);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class createFile_args implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("createFile_args");
    private static final TField PATH_FIELD_DESC = new TField("path", TType.STRUCT, (short)1);
    private static final TField MODE_FIELD_DESC = new TField("mode", TType.I16, (short)2);
    private static final TField OVERWRITE_FIELD_DESC = new TField("overwrite", TType.BOOL, (short)3);
    private static final TField BUFFER_SIZE_FIELD_DESC = new TField("bufferSize", TType.I32, (short)4);
    private static final TField BLOCK_REPLICATION_FIELD_DESC = new TField("block_replication", TType.I16, (short)5);
    private static final TField BLOCKSIZE_FIELD_DESC = new TField("blocksize", TType.I64, (short)6);

    public Pathname path;
    public static final int PATH = 1;
    public short mode;
    public static final int MODE = 2;
    public boolean overwrite;
    public static final int OVERWRITE = 3;
    public int bufferSize;
    public static final int BUFFERSIZE = 4;
    public short block_replication;
    public static final int BLOCK_REPLICATION = 5;
    public long blocksize;
    public static final int BLOCKSIZE = 6;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
      public boolean mode = false;
      public boolean overwrite = false;
      public boolean bufferSize = false;
      public boolean block_replication = false;
      public boolean blocksize = false;
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(PATH, new FieldMetaData("path", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, Pathname.class)));
      put(MODE, new FieldMetaData("mode", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.I16)));
      put(OVERWRITE, new FieldMetaData("overwrite", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.BOOL)));
      put(BUFFERSIZE, new FieldMetaData("bufferSize", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.I32)));
      put(BLOCK_REPLICATION, new FieldMetaData("block_replication", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.I16)));
      put(BLOCKSIZE, new FieldMetaData("blocksize", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.I64)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(createFile_args.class, metaDataMap);
    }

    public createFile_args() {
    }

    public createFile_args(
      Pathname path,
      short mode,
      boolean overwrite,
      int bufferSize,
      short block_replication,
      long blocksize)
    {
      this();
      this.path = path;
      this.mode = mode;
      this.__isset.mode = true;
      this.overwrite = overwrite;
      this.__isset.overwrite = true;
      this.bufferSize = bufferSize;
      this.__isset.bufferSize = true;
      this.block_replication = block_replication;
      this.__isset.block_replication = true;
      this.blocksize = blocksize;
      this.__isset.blocksize = true;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public createFile_args(createFile_args other) {
      if (other.isSetPath()) {
        this.path = new Pathname(other.path);
      }
      __isset.mode = other.__isset.mode;
      this.mode = other.mode;
      __isset.overwrite = other.__isset.overwrite;
      this.overwrite = other.overwrite;
      __isset.bufferSize = other.__isset.bufferSize;
      this.bufferSize = other.bufferSize;
      __isset.block_replication = other.__isset.block_replication;
      this.block_replication = other.block_replication;
      __isset.blocksize = other.__isset.blocksize;
      this.blocksize = other.blocksize;
    }

    @Override
    public createFile_args clone() {
      return new createFile_args(this);
    }

    public Pathname getPath() {
      return this.path;
    }

    public void setPath(Pathname path) {
      this.path = path;
    }

    public void unsetPath() {
      this.path = null;
    }

    // Returns true if field path is set (has been asigned a value) and false otherwise
    public boolean isSetPath() {
      return this.path != null;
    }

    public void setPathIsSet(boolean value) {
      if (!value) {
        this.path = null;
      }
    }

    public short getMode() {
      return this.mode;
    }

    public void setMode(short mode) {
      this.mode = mode;
      this.__isset.mode = true;
    }

    public void unsetMode() {
      this.__isset.mode = false;
    }

    // Returns true if field mode is set (has been asigned a value) and false otherwise
    public boolean isSetMode() {
      return this.__isset.mode;
    }

    public void setModeIsSet(boolean value) {
      this.__isset.mode = value;
    }

    public boolean isOverwrite() {
      return this.overwrite;
    }

    public void setOverwrite(boolean overwrite) {
      this.overwrite = overwrite;
      this.__isset.overwrite = true;
    }

    public void unsetOverwrite() {
      this.__isset.overwrite = false;
    }

    // Returns true if field overwrite is set (has been asigned a value) and false otherwise
    public boolean isSetOverwrite() {
      return this.__isset.overwrite;
    }

    public void setOverwriteIsSet(boolean value) {
      this.__isset.overwrite = value;
    }

    public int getBufferSize() {
      return this.bufferSize;
    }

    public void setBufferSize(int bufferSize) {
      this.bufferSize = bufferSize;
      this.__isset.bufferSize = true;
    }

    public void unsetBufferSize() {
      this.__isset.bufferSize = false;
    }

    // Returns true if field bufferSize is set (has been asigned a value) and false otherwise
    public boolean isSetBufferSize() {
      return this.__isset.bufferSize;
    }

    public void setBufferSizeIsSet(boolean value) {
      this.__isset.bufferSize = value;
    }

    public short getBlock_replication() {
      return this.block_replication;
    }

    public void setBlock_replication(short block_replication) {
      this.block_replication = block_replication;
      this.__isset.block_replication = true;
    }

    public void unsetBlock_replication() {
      this.__isset.block_replication = false;
    }

    // Returns true if field block_replication is set (has been asigned a value) and false otherwise
    public boolean isSetBlock_replication() {
      return this.__isset.block_replication;
    }

    public void setBlock_replicationIsSet(boolean value) {
      this.__isset.block_replication = value;
    }

    public long getBlocksize() {
      return this.blocksize;
    }

    public void setBlocksize(long blocksize) {
      this.blocksize = blocksize;
      this.__isset.blocksize = true;
    }

    public void unsetBlocksize() {
      this.__isset.blocksize = false;
    }

    // Returns true if field blocksize is set (has been asigned a value) and false otherwise
    public boolean isSetBlocksize() {
      return this.__isset.blocksize;
    }

    public void setBlocksizeIsSet(boolean value) {
      this.__isset.blocksize = value;
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case PATH:
        if (value == null) {
          unsetPath();
        } else {
          setPath((Pathname)value);
        }
        break;

      case MODE:
        if (value == null) {
          unsetMode();
        } else {
          setMode((Short)value);
        }
        break;

      case OVERWRITE:
        if (value == null) {
          unsetOverwrite();
        } else {
          setOverwrite((Boolean)value);
        }
        break;

      case BUFFERSIZE:
        if (value == null) {
          unsetBufferSize();
        } else {
          setBufferSize((Integer)value);
        }
        break;

      case BLOCK_REPLICATION:
        if (value == null) {
          unsetBlock_replication();
        } else {
          setBlock_replication((Short)value);
        }
        break;

      case BLOCKSIZE:
        if (value == null) {
          unsetBlocksize();
        } else {
          setBlocksize((Long)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case PATH:
        return getPath();

      case MODE:
        return new Short(getMode());

      case OVERWRITE:
        return new Boolean(isOverwrite());

      case BUFFERSIZE:
        return new Integer(getBufferSize());

      case BLOCK_REPLICATION:
        return new Short(getBlock_replication());

      case BLOCKSIZE:
        return new Long(getBlocksize());

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case PATH:
        return isSetPath();
      case MODE:
        return isSetMode();
      case OVERWRITE:
        return isSetOverwrite();
      case BUFFERSIZE:
        return isSetBufferSize();
      case BLOCK_REPLICATION:
        return isSetBlock_replication();
      case BLOCKSIZE:
        return isSetBlocksize();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof createFile_args)
        return this.equals((createFile_args)that);
      return false;
    }

    public boolean equals(createFile_args that) {
      if (that == null)
        return false;

      boolean this_present_path = true && this.isSetPath();
      boolean that_present_path = true && that.isSetPath();
      if (this_present_path || that_present_path) {
        if (!(this_present_path && that_present_path))
          return false;
        if (!this.path.equals(that.path))
          return false;
      }

      boolean this_present_mode = true;
      boolean that_present_mode = true;
      if (this_present_mode || that_present_mode) {
        if (!(this_present_mode && that_present_mode))
          return false;
        if (this.mode != that.mode)
          return false;
      }

      boolean this_present_overwrite = true;
      boolean that_present_overwrite = true;
      if (this_present_overwrite || that_present_overwrite) {
        if (!(this_present_overwrite && that_present_overwrite))
          return false;
        if (this.overwrite != that.overwrite)
          return false;
      }

      boolean this_present_bufferSize = true;
      boolean that_present_bufferSize = true;
      if (this_present_bufferSize || that_present_bufferSize) {
        if (!(this_present_bufferSize && that_present_bufferSize))
          return false;
        if (this.bufferSize != that.bufferSize)
          return false;
      }

      boolean this_present_block_replication = true;
      boolean that_present_block_replication = true;
      if (this_present_block_replication || that_present_block_replication) {
        if (!(this_present_block_replication && that_present_block_replication))
          return false;
        if (this.block_replication != that.block_replication)
          return false;
      }

      boolean this_present_blocksize = true;
      boolean that_present_blocksize = true;
      if (this_present_blocksize || that_present_blocksize) {
        if (!(this_present_blocksize && that_present_blocksize))
          return false;
        if (this.blocksize != that.blocksize)
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case PATH:
            if (field.type == TType.STRUCT) {
              this.path = new Pathname();
              this.path.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case MODE:
            if (field.type == TType.I16) {
              this.mode = iprot.readI16();
              this.__isset.mode = true;
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case OVERWRITE:
            if (field.type == TType.BOOL) {
              this.overwrite = iprot.readBool();
              this.__isset.overwrite = true;
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case BUFFERSIZE:
            if (field.type == TType.I32) {
              this.bufferSize = iprot.readI32();
              this.__isset.bufferSize = true;
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case BLOCK_REPLICATION:
            if (field.type == TType.I16) {
              this.block_replication = iprot.readI16();
              this.__isset.block_replication = true;
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case BLOCKSIZE:
            if (field.type == TType.I64) {
              this.blocksize = iprot.readI64();
              this.__isset.blocksize = true;
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.path != null) {
        oprot.writeFieldBegin(PATH_FIELD_DESC);
        this.path.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldBegin(MODE_FIELD_DESC);
      oprot.writeI16(this.mode);
      oprot.writeFieldEnd();
      oprot.writeFieldBegin(OVERWRITE_FIELD_DESC);
      oprot.writeBool(this.overwrite);
      oprot.writeFieldEnd();
      oprot.writeFieldBegin(BUFFER_SIZE_FIELD_DESC);
      oprot.writeI32(this.bufferSize);
      oprot.writeFieldEnd();
      oprot.writeFieldBegin(BLOCK_REPLICATION_FIELD_DESC);
      oprot.writeI16(this.block_replication);
      oprot.writeFieldEnd();
      oprot.writeFieldBegin(BLOCKSIZE_FIELD_DESC);
      oprot.writeI64(this.blocksize);
      oprot.writeFieldEnd();
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("createFile_args(");
      boolean first = true;

      sb.append("path:");
      if (this.path == null) {
        sb.append("null");
      } else {
        sb.append(this.path);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("mode:");
      sb.append(this.mode);
      first = false;
      if (!first) sb.append(", ");
      sb.append("overwrite:");
      sb.append(this.overwrite);
      first = false;
      if (!first) sb.append(", ");
      sb.append("bufferSize:");
      sb.append(this.bufferSize);
      first = false;
      if (!first) sb.append(", ");
      sb.append("block_replication:");
      sb.append(this.block_replication);
      first = false;
      if (!first) sb.append(", ");
      sb.append("blocksize:");
      sb.append(this.blocksize);
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class createFile_result implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("createFile_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);
    private static final TField OUCH_FIELD_DESC = new TField("ouch", TType.STRUCT, (short)1);

    public ThriftHandle success;
    public static final int SUCCESS = 0;
    public ThriftIOException ouch;
    public static final int OUCH = 1;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ThriftHandle.class)));
      put(OUCH, new FieldMetaData("ouch", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(createFile_result.class, metaDataMap);
    }

    public createFile_result() {
    }

    public createFile_result(
      ThriftHandle success,
      ThriftIOException ouch)
    {
      this();
      this.success = success;
      this.ouch = ouch;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public createFile_result(createFile_result other) {
      if (other.isSetSuccess()) {
        this.success = new ThriftHandle(other.success);
      }
      if (other.isSetOuch()) {
        this.ouch = new ThriftIOException(other.ouch);
      }
    }

    @Override
    public createFile_result clone() {
      return new createFile_result(this);
    }

    public ThriftHandle getSuccess() {
      return this.success;
    }

    public void setSuccess(ThriftHandle success) {
      this.success = success;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been asigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public ThriftIOException getOuch() {
      return this.ouch;
    }

    public void setOuch(ThriftIOException ouch) {
      this.ouch = ouch;
    }

    public void unsetOuch() {
      this.ouch = null;
    }

    // Returns true if field ouch is set (has been asigned a value) and false otherwise
    public boolean isSetOuch() {
      return this.ouch != null;
    }

    public void setOuchIsSet(boolean value) {
      if (!value) {
        this.ouch = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((ThriftHandle)value);
        }
        break;

      case OUCH:
        if (value == null) {
          unsetOuch();
        } else {
          setOuch((ThriftIOException)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      case OUCH:
        return getOuch();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case OUCH:
        return isSetOuch();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof createFile_result)
        return this.equals((createFile_result)that);
      return false;
    }

    public boolean equals(createFile_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      boolean this_present_ouch = true && this.isSetOuch();
      boolean that_present_ouch = true && that.isSetOuch();
      if (this_present_ouch || that_present_ouch) {
        if (!(this_present_ouch && that_present_ouch))
          return false;
        if (!this.ouch.equals(that.ouch))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case SUCCESS:
            if (field.type == TType.STRUCT) {
              this.success = new ThriftHandle();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case OUCH:
            if (field.type == TType.STRUCT) {
              this.ouch = new ThriftIOException();
              this.ouch.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      } else if (this.isSetOuch()) {
        oprot.writeFieldBegin(OUCH_FIELD_DESC);
        this.ouch.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("createFile_result(");
      boolean first = true;

      sb.append("success:");
      if (this.success == null) {
        sb.append("null");
      } else {
        sb.append(this.success);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("ouch:");
      if (this.ouch == null) {
        sb.append("null");
      } else {
        sb.append(this.ouch);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class open_args implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("open_args");
    private static final TField PATH_FIELD_DESC = new TField("path", TType.STRUCT, (short)1);

    public Pathname path;
    public static final int PATH = 1;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(PATH, new FieldMetaData("path", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, Pathname.class)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(open_args.class, metaDataMap);
    }

    public open_args() {
    }

    public open_args(
      Pathname path)
    {
      this();
      this.path = path;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public open_args(open_args other) {
      if (other.isSetPath()) {
        this.path = new Pathname(other.path);
      }
    }

    @Override
    public open_args clone() {
      return new open_args(this);
    }

    public Pathname getPath() {
      return this.path;
    }

    public void setPath(Pathname path) {
      this.path = path;
    }

    public void unsetPath() {
      this.path = null;
    }

    // Returns true if field path is set (has been asigned a value) and false otherwise
    public boolean isSetPath() {
      return this.path != null;
    }

    public void setPathIsSet(boolean value) {
      if (!value) {
        this.path = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case PATH:
        if (value == null) {
          unsetPath();
        } else {
          setPath((Pathname)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case PATH:
        return getPath();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case PATH:
        return isSetPath();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof open_args)
        return this.equals((open_args)that);
      return false;
    }

    public boolean equals(open_args that) {
      if (that == null)
        return false;

      boolean this_present_path = true && this.isSetPath();
      boolean that_present_path = true && that.isSetPath();
      if (this_present_path || that_present_path) {
        if (!(this_present_path && that_present_path))
          return false;
        if (!this.path.equals(that.path))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case PATH:
            if (field.type == TType.STRUCT) {
              this.path = new Pathname();
              this.path.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.path != null) {
        oprot.writeFieldBegin(PATH_FIELD_DESC);
        this.path.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("open_args(");
      boolean first = true;

      sb.append("path:");
      if (this.path == null) {
        sb.append("null");
      } else {
        sb.append(this.path);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class open_result implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("open_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);
    private static final TField OUCH_FIELD_DESC = new TField("ouch", TType.STRUCT, (short)1);

    public ThriftHandle success;
    public static final int SUCCESS = 0;
    public ThriftIOException ouch;
    public static final int OUCH = 1;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ThriftHandle.class)));
      put(OUCH, new FieldMetaData("ouch", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(open_result.class, metaDataMap);
    }

    public open_result() {
    }

    public open_result(
      ThriftHandle success,
      ThriftIOException ouch)
    {
      this();
      this.success = success;
      this.ouch = ouch;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public open_result(open_result other) {
      if (other.isSetSuccess()) {
        this.success = new ThriftHandle(other.success);
      }
      if (other.isSetOuch()) {
        this.ouch = new ThriftIOException(other.ouch);
      }
    }

    @Override
    public open_result clone() {
      return new open_result(this);
    }

    public ThriftHandle getSuccess() {
      return this.success;
    }

    public void setSuccess(ThriftHandle success) {
      this.success = success;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been asigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public ThriftIOException getOuch() {
      return this.ouch;
    }

    public void setOuch(ThriftIOException ouch) {
      this.ouch = ouch;
    }

    public void unsetOuch() {
      this.ouch = null;
    }

    // Returns true if field ouch is set (has been asigned a value) and false otherwise
    public boolean isSetOuch() {
      return this.ouch != null;
    }

    public void setOuchIsSet(boolean value) {
      if (!value) {
        this.ouch = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((ThriftHandle)value);
        }
        break;

      case OUCH:
        if (value == null) {
          unsetOuch();
        } else {
          setOuch((ThriftIOException)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      case OUCH:
        return getOuch();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case OUCH:
        return isSetOuch();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof open_result)
        return this.equals((open_result)that);
      return false;
    }

    public boolean equals(open_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      boolean this_present_ouch = true && this.isSetOuch();
      boolean that_present_ouch = true && that.isSetOuch();
      if (this_present_ouch || that_present_ouch) {
        if (!(this_present_ouch && that_present_ouch))
          return false;
        if (!this.ouch.equals(that.ouch))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case SUCCESS:
            if (field.type == TType.STRUCT) {
              this.success = new ThriftHandle();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case OUCH:
            if (field.type == TType.STRUCT) {
              this.ouch = new ThriftIOException();
              this.ouch.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      } else if (this.isSetOuch()) {
        oprot.writeFieldBegin(OUCH_FIELD_DESC);
        this.ouch.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("open_result(");
      boolean first = true;

      sb.append("success:");
      if (this.success == null) {
        sb.append("null");
      } else {
        sb.append(this.success);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("ouch:");
      if (this.ouch == null) {
        sb.append("null");
      } else {
        sb.append(this.ouch);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class append_args implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("append_args");
    private static final TField PATH_FIELD_DESC = new TField("path", TType.STRUCT, (short)1);

    public Pathname path;
    public static final int PATH = 1;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(PATH, new FieldMetaData("path", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, Pathname.class)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(append_args.class, metaDataMap);
    }

    public append_args() {
    }

    public append_args(
      Pathname path)
    {
      this();
      this.path = path;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public append_args(append_args other) {
      if (other.isSetPath()) {
        this.path = new Pathname(other.path);
      }
    }

    @Override
    public append_args clone() {
      return new append_args(this);
    }

    public Pathname getPath() {
      return this.path;
    }

    public void setPath(Pathname path) {
      this.path = path;
    }

    public void unsetPath() {
      this.path = null;
    }

    // Returns true if field path is set (has been asigned a value) and false otherwise
    public boolean isSetPath() {
      return this.path != null;
    }

    public void setPathIsSet(boolean value) {
      if (!value) {
        this.path = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case PATH:
        if (value == null) {
          unsetPath();
        } else {
          setPath((Pathname)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case PATH:
        return getPath();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case PATH:
        return isSetPath();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof append_args)
        return this.equals((append_args)that);
      return false;
    }

    public boolean equals(append_args that) {
      if (that == null)
        return false;

      boolean this_present_path = true && this.isSetPath();
      boolean that_present_path = true && that.isSetPath();
      if (this_present_path || that_present_path) {
        if (!(this_present_path && that_present_path))
          return false;
        if (!this.path.equals(that.path))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case PATH:
            if (field.type == TType.STRUCT) {
              this.path = new Pathname();
              this.path.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.path != null) {
        oprot.writeFieldBegin(PATH_FIELD_DESC);
        this.path.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("append_args(");
      boolean first = true;

      sb.append("path:");
      if (this.path == null) {
        sb.append("null");
      } else {
        sb.append(this.path);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class append_result implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("append_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);
    private static final TField OUCH_FIELD_DESC = new TField("ouch", TType.STRUCT, (short)1);

    public ThriftHandle success;
    public static final int SUCCESS = 0;
    public ThriftIOException ouch;
    public static final int OUCH = 1;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ThriftHandle.class)));
      put(OUCH, new FieldMetaData("ouch", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(append_result.class, metaDataMap);
    }

    public append_result() {
    }

    public append_result(
      ThriftHandle success,
      ThriftIOException ouch)
    {
      this();
      this.success = success;
      this.ouch = ouch;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public append_result(append_result other) {
      if (other.isSetSuccess()) {
        this.success = new ThriftHandle(other.success);
      }
      if (other.isSetOuch()) {
        this.ouch = new ThriftIOException(other.ouch);
      }
    }

    @Override
    public append_result clone() {
      return new append_result(this);
    }

    public ThriftHandle getSuccess() {
      return this.success;
    }

    public void setSuccess(ThriftHandle success) {
      this.success = success;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been asigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public ThriftIOException getOuch() {
      return this.ouch;
    }

    public void setOuch(ThriftIOException ouch) {
      this.ouch = ouch;
    }

    public void unsetOuch() {
      this.ouch = null;
    }

    // Returns true if field ouch is set (has been asigned a value) and false otherwise
    public boolean isSetOuch() {
      return this.ouch != null;
    }

    public void setOuchIsSet(boolean value) {
      if (!value) {
        this.ouch = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((ThriftHandle)value);
        }
        break;

      case OUCH:
        if (value == null) {
          unsetOuch();
        } else {
          setOuch((ThriftIOException)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      case OUCH:
        return getOuch();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case OUCH:
        return isSetOuch();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof append_result)
        return this.equals((append_result)that);
      return false;
    }

    public boolean equals(append_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      boolean this_present_ouch = true && this.isSetOuch();
      boolean that_present_ouch = true && that.isSetOuch();
      if (this_present_ouch || that_present_ouch) {
        if (!(this_present_ouch && that_present_ouch))
          return false;
        if (!this.ouch.equals(that.ouch))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case SUCCESS:
            if (field.type == TType.STRUCT) {
              this.success = new ThriftHandle();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case OUCH:
            if (field.type == TType.STRUCT) {
              this.ouch = new ThriftIOException();
              this.ouch.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      } else if (this.isSetOuch()) {
        oprot.writeFieldBegin(OUCH_FIELD_DESC);
        this.ouch.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("append_result(");
      boolean first = true;

      sb.append("success:");
      if (this.success == null) {
        sb.append("null");
      } else {
        sb.append(this.success);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("ouch:");
      if (this.ouch == null) {
        sb.append("null");
      } else {
        sb.append(this.ouch);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class write_args implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("write_args");
    private static final TField HANDLE_FIELD_DESC = new TField("handle", TType.STRUCT, (short)1);
    private static final TField DATA_FIELD_DESC = new TField("data", TType.STRING, (short)2);

    public ThriftHandle handle;
    public static final int HANDLE = 1;
    public String data;
    public static final int DATA = 2;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(HANDLE, new FieldMetaData("handle", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ThriftHandle.class)));
      put(DATA, new FieldMetaData("data", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(write_args.class, metaDataMap);
    }

    public write_args() {
    }

    public write_args(
      ThriftHandle handle,
      String data)
    {
      this();
      this.handle = handle;
      this.data = data;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public write_args(write_args other) {
      if (other.isSetHandle()) {
        this.handle = new ThriftHandle(other.handle);
      }
      if (other.isSetData()) {
        this.data = other.data;
      }
    }

    @Override
    public write_args clone() {
      return new write_args(this);
    }

    public ThriftHandle getHandle() {
      return this.handle;
    }

    public void setHandle(ThriftHandle handle) {
      this.handle = handle;
    }

    public void unsetHandle() {
      this.handle = null;
    }

    // Returns true if field handle is set (has been asigned a value) and false otherwise
    public boolean isSetHandle() {
      return this.handle != null;
    }

    public void setHandleIsSet(boolean value) {
      if (!value) {
        this.handle = null;
      }
    }

    public String getData() {
      return this.data;
    }

    public void setData(String data) {
      this.data = data;
    }

    public void unsetData() {
      this.data = null;
    }

    // Returns true if field data is set (has been asigned a value) and false otherwise
    public boolean isSetData() {
      return this.data != null;
    }

    public void setDataIsSet(boolean value) {
      if (!value) {
        this.data = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case HANDLE:
        if (value == null) {
          unsetHandle();
        } else {
          setHandle((ThriftHandle)value);
        }
        break;

      case DATA:
        if (value == null) {
          unsetData();
        } else {
          setData((String)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case HANDLE:
        return getHandle();

      case DATA:
        return getData();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case HANDLE:
        return isSetHandle();
      case DATA:
        return isSetData();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof write_args)
        return this.equals((write_args)that);
      return false;
    }

    public boolean equals(write_args that) {
      if (that == null)
        return false;

      boolean this_present_handle = true && this.isSetHandle();
      boolean that_present_handle = true && that.isSetHandle();
      if (this_present_handle || that_present_handle) {
        if (!(this_present_handle && that_present_handle))
          return false;
        if (!this.handle.equals(that.handle))
          return false;
      }

      boolean this_present_data = true && this.isSetData();
      boolean that_present_data = true && that.isSetData();
      if (this_present_data || that_present_data) {
        if (!(this_present_data && that_present_data))
          return false;
        if (!this.data.equals(that.data))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case HANDLE:
            if (field.type == TType.STRUCT) {
              this.handle = new ThriftHandle();
              this.handle.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case DATA:
            if (field.type == TType.STRING) {
              this.data = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.handle != null) {
        oprot.writeFieldBegin(HANDLE_FIELD_DESC);
        this.handle.write(oprot);
        oprot.writeFieldEnd();
      }
      if (this.data != null) {
        oprot.writeFieldBegin(DATA_FIELD_DESC);
        oprot.writeString(this.data);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("write_args(");
      boolean first = true;

      sb.append("handle:");
      if (this.handle == null) {
        sb.append("null");
      } else {
        sb.append(this.handle);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("data:");
      if (this.data == null) {
        sb.append("null");
      } else {
        sb.append(this.data);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class write_result implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("write_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.BOOL, (short)0);
    private static final TField OUCH_FIELD_DESC = new TField("ouch", TType.STRUCT, (short)1);

    public boolean success;
    public static final int SUCCESS = 0;
    public ThriftIOException ouch;
    public static final int OUCH = 1;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
      public boolean success = false;
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.BOOL)));
      put(OUCH, new FieldMetaData("ouch", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(write_result.class, metaDataMap);
    }

    public write_result() {
    }

    public write_result(
      boolean success,
      ThriftIOException ouch)
    {
      this();
      this.success = success;
      this.__isset.success = true;
      this.ouch = ouch;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public write_result(write_result other) {
      __isset.success = other.__isset.success;
      this.success = other.success;
      if (other.isSetOuch()) {
        this.ouch = new ThriftIOException(other.ouch);
      }
    }

    @Override
    public write_result clone() {
      return new write_result(this);
    }

    public boolean isSuccess() {
      return this.success;
    }

    public void setSuccess(boolean success) {
      this.success = success;
      this.__isset.success = true;
    }

    public void unsetSuccess() {
      this.__isset.success = false;
    }

    // Returns true if field success is set (has been asigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.__isset.success;
    }

    public void setSuccessIsSet(boolean value) {
      this.__isset.success = value;
    }

    public ThriftIOException getOuch() {
      return this.ouch;
    }

    public void setOuch(ThriftIOException ouch) {
      this.ouch = ouch;
    }

    public void unsetOuch() {
      this.ouch = null;
    }

    // Returns true if field ouch is set (has been asigned a value) and false otherwise
    public boolean isSetOuch() {
      return this.ouch != null;
    }

    public void setOuchIsSet(boolean value) {
      if (!value) {
        this.ouch = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((Boolean)value);
        }
        break;

      case OUCH:
        if (value == null) {
          unsetOuch();
        } else {
          setOuch((ThriftIOException)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return new Boolean(isSuccess());

      case OUCH:
        return getOuch();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case OUCH:
        return isSetOuch();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof write_result)
        return this.equals((write_result)that);
      return false;
    }

    public boolean equals(write_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true;
      boolean that_present_success = true;
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (this.success != that.success)
          return false;
      }

      boolean this_present_ouch = true && this.isSetOuch();
      boolean that_present_ouch = true && that.isSetOuch();
      if (this_present_ouch || that_present_ouch) {
        if (!(this_present_ouch && that_present_ouch))
          return false;
        if (!this.ouch.equals(that.ouch))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case SUCCESS:
            if (field.type == TType.BOOL) {
              this.success = iprot.readBool();
              this.__isset.success = true;
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case OUCH:
            if (field.type == TType.STRUCT) {
              this.ouch = new ThriftIOException();
              this.ouch.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        oprot.writeBool(this.success);
        oprot.writeFieldEnd();
      } else if (this.isSetOuch()) {
        oprot.writeFieldBegin(OUCH_FIELD_DESC);
        this.ouch.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("write_result(");
      boolean first = true;

      sb.append("success:");
      sb.append(this.success);
      first = false;
      if (!first) sb.append(", ");
      sb.append("ouch:");
      if (this.ouch == null) {
        sb.append("null");
      } else {
        sb.append(this.ouch);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class read_args implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("read_args");
    private static final TField HANDLE_FIELD_DESC = new TField("handle", TType.STRUCT, (short)1);
    private static final TField OFFSET_FIELD_DESC = new TField("offset", TType.I64, (short)2);
    private static final TField SIZE_FIELD_DESC = new TField("size", TType.I32, (short)3);

    public ThriftHandle handle;
    public static final int HANDLE = 1;
    public long offset;
    public static final int OFFSET = 2;
    public int size;
    public static final int SIZE = 3;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
      public boolean offset = false;
      public boolean size = false;
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(HANDLE, new FieldMetaData("handle", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ThriftHandle.class)));
      put(OFFSET, new FieldMetaData("offset", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.I64)));
      put(SIZE, new FieldMetaData("size", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.I32)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(read_args.class, metaDataMap);
    }

    public read_args() {
    }

    public read_args(
      ThriftHandle handle,
      long offset,
      int size)
    {
      this();
      this.handle = handle;
      this.offset = offset;
      this.__isset.offset = true;
      this.size = size;
      this.__isset.size = true;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public read_args(read_args other) {
      if (other.isSetHandle()) {
        this.handle = new ThriftHandle(other.handle);
      }
      __isset.offset = other.__isset.offset;
      this.offset = other.offset;
      __isset.size = other.__isset.size;
      this.size = other.size;
    }

    @Override
    public read_args clone() {
      return new read_args(this);
    }

    public ThriftHandle getHandle() {
      return this.handle;
    }

    public void setHandle(ThriftHandle handle) {
      this.handle = handle;
    }

    public void unsetHandle() {
      this.handle = null;
    }

    // Returns true if field handle is set (has been asigned a value) and false otherwise
    public boolean isSetHandle() {
      return this.handle != null;
    }

    public void setHandleIsSet(boolean value) {
      if (!value) {
        this.handle = null;
      }
    }

    public long getOffset() {
      return this.offset;
    }

    public void setOffset(long offset) {
      this.offset = offset;
      this.__isset.offset = true;
    }

    public void unsetOffset() {
      this.__isset.offset = false;
    }

    // Returns true if field offset is set (has been asigned a value) and false otherwise
    public boolean isSetOffset() {
      return this.__isset.offset;
    }

    public void setOffsetIsSet(boolean value) {
      this.__isset.offset = value;
    }

    public int getSize() {
      return this.size;
    }

    public void setSize(int size) {
      this.size = size;
      this.__isset.size = true;
    }

    public void unsetSize() {
      this.__isset.size = false;
    }

    // Returns true if field size is set (has been asigned a value) and false otherwise
    public boolean isSetSize() {
      return this.__isset.size;
    }

    public void setSizeIsSet(boolean value) {
      this.__isset.size = value;
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case HANDLE:
        if (value == null) {
          unsetHandle();
        } else {
          setHandle((ThriftHandle)value);
        }
        break;

      case OFFSET:
        if (value == null) {
          unsetOffset();
        } else {
          setOffset((Long)value);
        }
        break;

      case SIZE:
        if (value == null) {
          unsetSize();
        } else {
          setSize((Integer)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case HANDLE:
        return getHandle();

      case OFFSET:
        return new Long(getOffset());

      case SIZE:
        return new Integer(getSize());

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case HANDLE:
        return isSetHandle();
      case OFFSET:
        return isSetOffset();
      case SIZE:
        return isSetSize();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof read_args)
        return this.equals((read_args)that);
      return false;
    }

    public boolean equals(read_args that) {
      if (that == null)
        return false;

      boolean this_present_handle = true && this.isSetHandle();
      boolean that_present_handle = true && that.isSetHandle();
      if (this_present_handle || that_present_handle) {
        if (!(this_present_handle && that_present_handle))
          return false;
        if (!this.handle.equals(that.handle))
          return false;
      }

      boolean this_present_offset = true;
      boolean that_present_offset = true;
      if (this_present_offset || that_present_offset) {
        if (!(this_present_offset && that_present_offset))
          return false;
        if (this.offset != that.offset)
          return false;
      }

      boolean this_present_size = true;
      boolean that_present_size = true;
      if (this_present_size || that_present_size) {
        if (!(this_present_size && that_present_size))
          return false;
        if (this.size != that.size)
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case HANDLE:
            if (field.type == TType.STRUCT) {
              this.handle = new ThriftHandle();
              this.handle.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case OFFSET:
            if (field.type == TType.I64) {
              this.offset = iprot.readI64();
              this.__isset.offset = true;
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case SIZE:
            if (field.type == TType.I32) {
              this.size = iprot.readI32();
              this.__isset.size = true;
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.handle != null) {
        oprot.writeFieldBegin(HANDLE_FIELD_DESC);
        this.handle.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldBegin(OFFSET_FIELD_DESC);
      oprot.writeI64(this.offset);
      oprot.writeFieldEnd();
      oprot.writeFieldBegin(SIZE_FIELD_DESC);
      oprot.writeI32(this.size);
      oprot.writeFieldEnd();
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("read_args(");
      boolean first = true;

      sb.append("handle:");
      if (this.handle == null) {
        sb.append("null");
      } else {
        sb.append(this.handle);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("offset:");
      sb.append(this.offset);
      first = false;
      if (!first) sb.append(", ");
      sb.append("size:");
      sb.append(this.size);
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class read_result implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("read_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRING, (short)0);
    private static final TField OUCH_FIELD_DESC = new TField("ouch", TType.STRUCT, (short)1);

    public String success;
    public static final int SUCCESS = 0;
    public ThriftIOException ouch;
    public static final int OUCH = 1;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      put(OUCH, new FieldMetaData("ouch", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(read_result.class, metaDataMap);
    }

    public read_result() {
    }

    public read_result(
      String success,
      ThriftIOException ouch)
    {
      this();
      this.success = success;
      this.ouch = ouch;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public read_result(read_result other) {
      if (other.isSetSuccess()) {
        this.success = other.success;
      }
      if (other.isSetOuch()) {
        this.ouch = new ThriftIOException(other.ouch);
      }
    }

    @Override
    public read_result clone() {
      return new read_result(this);
    }

    public String getSuccess() {
      return this.success;
    }

    public void setSuccess(String success) {
      this.success = success;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been asigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public ThriftIOException getOuch() {
      return this.ouch;
    }

    public void setOuch(ThriftIOException ouch) {
      this.ouch = ouch;
    }

    public void unsetOuch() {
      this.ouch = null;
    }

    // Returns true if field ouch is set (has been asigned a value) and false otherwise
    public boolean isSetOuch() {
      return this.ouch != null;
    }

    public void setOuchIsSet(boolean value) {
      if (!value) {
        this.ouch = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((String)value);
        }
        break;

      case OUCH:
        if (value == null) {
          unsetOuch();
        } else {
          setOuch((ThriftIOException)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      case OUCH:
        return getOuch();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case OUCH:
        return isSetOuch();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof read_result)
        return this.equals((read_result)that);
      return false;
    }

    public boolean equals(read_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      boolean this_present_ouch = true && this.isSetOuch();
      boolean that_present_ouch = true && that.isSetOuch();
      if (this_present_ouch || that_present_ouch) {
        if (!(this_present_ouch && that_present_ouch))
          return false;
        if (!this.ouch.equals(that.ouch))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case SUCCESS:
            if (field.type == TType.STRING) {
              this.success = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case OUCH:
            if (field.type == TType.STRUCT) {
              this.ouch = new ThriftIOException();
              this.ouch.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        oprot.writeString(this.success);
        oprot.writeFieldEnd();
      } else if (this.isSetOuch()) {
        oprot.writeFieldBegin(OUCH_FIELD_DESC);
        this.ouch.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("read_result(");
      boolean first = true;

      sb.append("success:");
      if (this.success == null) {
        sb.append("null");
      } else {
        sb.append(this.success);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("ouch:");
      if (this.ouch == null) {
        sb.append("null");
      } else {
        sb.append(this.ouch);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class close_args implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("close_args");
    private static final TField OUT_FIELD_DESC = new TField("out", TType.STRUCT, (short)1);

    public ThriftHandle out;
    public static final int OUT = 1;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(OUT, new FieldMetaData("out", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ThriftHandle.class)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(close_args.class, metaDataMap);
    }

    public close_args() {
    }

    public close_args(
      ThriftHandle out)
    {
      this();
      this.out = out;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public close_args(close_args other) {
      if (other.isSetOut()) {
        this.out = new ThriftHandle(other.out);
      }
    }

    @Override
    public close_args clone() {
      return new close_args(this);
    }

    public ThriftHandle getOut() {
      return this.out;
    }

    public void setOut(ThriftHandle out) {
      this.out = out;
    }

    public void unsetOut() {
      this.out = null;
    }

    // Returns true if field out is set (has been asigned a value) and false otherwise
    public boolean isSetOut() {
      return this.out != null;
    }

    public void setOutIsSet(boolean value) {
      if (!value) {
        this.out = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case OUT:
        if (value == null) {
          unsetOut();
        } else {
          setOut((ThriftHandle)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case OUT:
        return getOut();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case OUT:
        return isSetOut();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof close_args)
        return this.equals((close_args)that);
      return false;
    }

    public boolean equals(close_args that) {
      if (that == null)
        return false;

      boolean this_present_out = true && this.isSetOut();
      boolean that_present_out = true && that.isSetOut();
      if (this_present_out || that_present_out) {
        if (!(this_present_out && that_present_out))
          return false;
        if (!this.out.equals(that.out))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case OUT:
            if (field.type == TType.STRUCT) {
              this.out = new ThriftHandle();
              this.out.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.out != null) {
        oprot.writeFieldBegin(OUT_FIELD_DESC);
        this.out.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("close_args(");
      boolean first = true;

      sb.append("out:");
      if (this.out == null) {
        sb.append("null");
      } else {
        sb.append(this.out);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class close_result implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("close_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.BOOL, (short)0);
    private static final TField OUCH_FIELD_DESC = new TField("ouch", TType.STRUCT, (short)1);

    public boolean success;
    public static final int SUCCESS = 0;
    public ThriftIOException ouch;
    public static final int OUCH = 1;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
      public boolean success = false;
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.BOOL)));
      put(OUCH, new FieldMetaData("ouch", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(close_result.class, metaDataMap);
    }

    public close_result() {
    }

    public close_result(
      boolean success,
      ThriftIOException ouch)
    {
      this();
      this.success = success;
      this.__isset.success = true;
      this.ouch = ouch;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public close_result(close_result other) {
      __isset.success = other.__isset.success;
      this.success = other.success;
      if (other.isSetOuch()) {
        this.ouch = new ThriftIOException(other.ouch);
      }
    }

    @Override
    public close_result clone() {
      return new close_result(this);
    }

    public boolean isSuccess() {
      return this.success;
    }

    public void setSuccess(boolean success) {
      this.success = success;
      this.__isset.success = true;
    }

    public void unsetSuccess() {
      this.__isset.success = false;
    }

    // Returns true if field success is set (has been asigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.__isset.success;
    }

    public void setSuccessIsSet(boolean value) {
      this.__isset.success = value;
    }

    public ThriftIOException getOuch() {
      return this.ouch;
    }

    public void setOuch(ThriftIOException ouch) {
      this.ouch = ouch;
    }

    public void unsetOuch() {
      this.ouch = null;
    }

    // Returns true if field ouch is set (has been asigned a value) and false otherwise
    public boolean isSetOuch() {
      return this.ouch != null;
    }

    public void setOuchIsSet(boolean value) {
      if (!value) {
        this.ouch = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((Boolean)value);
        }
        break;

      case OUCH:
        if (value == null) {
          unsetOuch();
        } else {
          setOuch((ThriftIOException)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return new Boolean(isSuccess());

      case OUCH:
        return getOuch();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case OUCH:
        return isSetOuch();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof close_result)
        return this.equals((close_result)that);
      return false;
    }

    public boolean equals(close_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true;
      boolean that_present_success = true;
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (this.success != that.success)
          return false;
      }

      boolean this_present_ouch = true && this.isSetOuch();
      boolean that_present_ouch = true && that.isSetOuch();
      if (this_present_ouch || that_present_ouch) {
        if (!(this_present_ouch && that_present_ouch))
          return false;
        if (!this.ouch.equals(that.ouch))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case SUCCESS:
            if (field.type == TType.BOOL) {
              this.success = iprot.readBool();
              this.__isset.success = true;
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case OUCH:
            if (field.type == TType.STRUCT) {
              this.ouch = new ThriftIOException();
              this.ouch.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        oprot.writeBool(this.success);
        oprot.writeFieldEnd();
      } else if (this.isSetOuch()) {
        oprot.writeFieldBegin(OUCH_FIELD_DESC);
        this.ouch.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("close_result(");
      boolean first = true;

      sb.append("success:");
      sb.append(this.success);
      first = false;
      if (!first) sb.append(", ");
      sb.append("ouch:");
      if (this.ouch == null) {
        sb.append("null");
      } else {
        sb.append(this.ouch);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class rm_args implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("rm_args");
    private static final TField PATH_FIELD_DESC = new TField("path", TType.STRUCT, (short)1);
    private static final TField RECURSIVE_FIELD_DESC = new TField("recursive", TType.BOOL, (short)2);

    public Pathname path;
    public static final int PATH = 1;
    public boolean recursive;
    public static final int RECURSIVE = 2;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
      public boolean recursive = false;
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(PATH, new FieldMetaData("path", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, Pathname.class)));
      put(RECURSIVE, new FieldMetaData("recursive", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.BOOL)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(rm_args.class, metaDataMap);
    }

    public rm_args() {
    }

    public rm_args(
      Pathname path,
      boolean recursive)
    {
      this();
      this.path = path;
      this.recursive = recursive;
      this.__isset.recursive = true;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public rm_args(rm_args other) {
      if (other.isSetPath()) {
        this.path = new Pathname(other.path);
      }
      __isset.recursive = other.__isset.recursive;
      this.recursive = other.recursive;
    }

    @Override
    public rm_args clone() {
      return new rm_args(this);
    }

    public Pathname getPath() {
      return this.path;
    }

    public void setPath(Pathname path) {
      this.path = path;
    }

    public void unsetPath() {
      this.path = null;
    }

    // Returns true if field path is set (has been asigned a value) and false otherwise
    public boolean isSetPath() {
      return this.path != null;
    }

    public void setPathIsSet(boolean value) {
      if (!value) {
        this.path = null;
      }
    }

    public boolean isRecursive() {
      return this.recursive;
    }

    public void setRecursive(boolean recursive) {
      this.recursive = recursive;
      this.__isset.recursive = true;
    }

    public void unsetRecursive() {
      this.__isset.recursive = false;
    }

    // Returns true if field recursive is set (has been asigned a value) and false otherwise
    public boolean isSetRecursive() {
      return this.__isset.recursive;
    }

    public void setRecursiveIsSet(boolean value) {
      this.__isset.recursive = value;
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case PATH:
        if (value == null) {
          unsetPath();
        } else {
          setPath((Pathname)value);
        }
        break;

      case RECURSIVE:
        if (value == null) {
          unsetRecursive();
        } else {
          setRecursive((Boolean)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case PATH:
        return getPath();

      case RECURSIVE:
        return new Boolean(isRecursive());

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case PATH:
        return isSetPath();
      case RECURSIVE:
        return isSetRecursive();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof rm_args)
        return this.equals((rm_args)that);
      return false;
    }

    public boolean equals(rm_args that) {
      if (that == null)
        return false;

      boolean this_present_path = true && this.isSetPath();
      boolean that_present_path = true && that.isSetPath();
      if (this_present_path || that_present_path) {
        if (!(this_present_path && that_present_path))
          return false;
        if (!this.path.equals(that.path))
          return false;
      }

      boolean this_present_recursive = true;
      boolean that_present_recursive = true;
      if (this_present_recursive || that_present_recursive) {
        if (!(this_present_recursive && that_present_recursive))
          return false;
        if (this.recursive != that.recursive)
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case PATH:
            if (field.type == TType.STRUCT) {
              this.path = new Pathname();
              this.path.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case RECURSIVE:
            if (field.type == TType.BOOL) {
              this.recursive = iprot.readBool();
              this.__isset.recursive = true;
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.path != null) {
        oprot.writeFieldBegin(PATH_FIELD_DESC);
        this.path.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldBegin(RECURSIVE_FIELD_DESC);
      oprot.writeBool(this.recursive);
      oprot.writeFieldEnd();
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("rm_args(");
      boolean first = true;

      sb.append("path:");
      if (this.path == null) {
        sb.append("null");
      } else {
        sb.append(this.path);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("recursive:");
      sb.append(this.recursive);
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class rm_result implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("rm_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.BOOL, (short)0);
    private static final TField OUCH_FIELD_DESC = new TField("ouch", TType.STRUCT, (short)1);

    public boolean success;
    public static final int SUCCESS = 0;
    public ThriftIOException ouch;
    public static final int OUCH = 1;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
      public boolean success = false;
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.BOOL)));
      put(OUCH, new FieldMetaData("ouch", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(rm_result.class, metaDataMap);
    }

    public rm_result() {
    }

    public rm_result(
      boolean success,
      ThriftIOException ouch)
    {
      this();
      this.success = success;
      this.__isset.success = true;
      this.ouch = ouch;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public rm_result(rm_result other) {
      __isset.success = other.__isset.success;
      this.success = other.success;
      if (other.isSetOuch()) {
        this.ouch = new ThriftIOException(other.ouch);
      }
    }

    @Override
    public rm_result clone() {
      return new rm_result(this);
    }

    public boolean isSuccess() {
      return this.success;
    }

    public void setSuccess(boolean success) {
      this.success = success;
      this.__isset.success = true;
    }

    public void unsetSuccess() {
      this.__isset.success = false;
    }

    // Returns true if field success is set (has been asigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.__isset.success;
    }

    public void setSuccessIsSet(boolean value) {
      this.__isset.success = value;
    }

    public ThriftIOException getOuch() {
      return this.ouch;
    }

    public void setOuch(ThriftIOException ouch) {
      this.ouch = ouch;
    }

    public void unsetOuch() {
      this.ouch = null;
    }

    // Returns true if field ouch is set (has been asigned a value) and false otherwise
    public boolean isSetOuch() {
      return this.ouch != null;
    }

    public void setOuchIsSet(boolean value) {
      if (!value) {
        this.ouch = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((Boolean)value);
        }
        break;

      case OUCH:
        if (value == null) {
          unsetOuch();
        } else {
          setOuch((ThriftIOException)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return new Boolean(isSuccess());

      case OUCH:
        return getOuch();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case OUCH:
        return isSetOuch();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof rm_result)
        return this.equals((rm_result)that);
      return false;
    }

    public boolean equals(rm_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true;
      boolean that_present_success = true;
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (this.success != that.success)
          return false;
      }

      boolean this_present_ouch = true && this.isSetOuch();
      boolean that_present_ouch = true && that.isSetOuch();
      if (this_present_ouch || that_present_ouch) {
        if (!(this_present_ouch && that_present_ouch))
          return false;
        if (!this.ouch.equals(that.ouch))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case SUCCESS:
            if (field.type == TType.BOOL) {
              this.success = iprot.readBool();
              this.__isset.success = true;
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case OUCH:
            if (field.type == TType.STRUCT) {
              this.ouch = new ThriftIOException();
              this.ouch.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        oprot.writeBool(this.success);
        oprot.writeFieldEnd();
      } else if (this.isSetOuch()) {
        oprot.writeFieldBegin(OUCH_FIELD_DESC);
        this.ouch.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("rm_result(");
      boolean first = true;

      sb.append("success:");
      sb.append(this.success);
      first = false;
      if (!first) sb.append(", ");
      sb.append("ouch:");
      if (this.ouch == null) {
        sb.append("null");
      } else {
        sb.append(this.ouch);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class rename_args implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("rename_args");
    private static final TField PATH_FIELD_DESC = new TField("path", TType.STRUCT, (short)1);
    private static final TField DEST_FIELD_DESC = new TField("dest", TType.STRUCT, (short)2);

    public Pathname path;
    public static final int PATH = 1;
    public Pathname dest;
    public static final int DEST = 2;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(PATH, new FieldMetaData("path", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, Pathname.class)));
      put(DEST, new FieldMetaData("dest", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, Pathname.class)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(rename_args.class, metaDataMap);
    }

    public rename_args() {
    }

    public rename_args(
      Pathname path,
      Pathname dest)
    {
      this();
      this.path = path;
      this.dest = dest;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public rename_args(rename_args other) {
      if (other.isSetPath()) {
        this.path = new Pathname(other.path);
      }
      if (other.isSetDest()) {
        this.dest = new Pathname(other.dest);
      }
    }

    @Override
    public rename_args clone() {
      return new rename_args(this);
    }

    public Pathname getPath() {
      return this.path;
    }

    public void setPath(Pathname path) {
      this.path = path;
    }

    public void unsetPath() {
      this.path = null;
    }

    // Returns true if field path is set (has been asigned a value) and false otherwise
    public boolean isSetPath() {
      return this.path != null;
    }

    public void setPathIsSet(boolean value) {
      if (!value) {
        this.path = null;
      }
    }

    public Pathname getDest() {
      return this.dest;
    }

    public void setDest(Pathname dest) {
      this.dest = dest;
    }

    public void unsetDest() {
      this.dest = null;
    }

    // Returns true if field dest is set (has been asigned a value) and false otherwise
    public boolean isSetDest() {
      return this.dest != null;
    }

    public void setDestIsSet(boolean value) {
      if (!value) {
        this.dest = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case PATH:
        if (value == null) {
          unsetPath();
        } else {
          setPath((Pathname)value);
        }
        break;

      case DEST:
        if (value == null) {
          unsetDest();
        } else {
          setDest((Pathname)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case PATH:
        return getPath();

      case DEST:
        return getDest();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case PATH:
        return isSetPath();
      case DEST:
        return isSetDest();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof rename_args)
        return this.equals((rename_args)that);
      return false;
    }

    public boolean equals(rename_args that) {
      if (that == null)
        return false;

      boolean this_present_path = true && this.isSetPath();
      boolean that_present_path = true && that.isSetPath();
      if (this_present_path || that_present_path) {
        if (!(this_present_path && that_present_path))
          return false;
        if (!this.path.equals(that.path))
          return false;
      }

      boolean this_present_dest = true && this.isSetDest();
      boolean that_present_dest = true && that.isSetDest();
      if (this_present_dest || that_present_dest) {
        if (!(this_present_dest && that_present_dest))
          return false;
        if (!this.dest.equals(that.dest))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case PATH:
            if (field.type == TType.STRUCT) {
              this.path = new Pathname();
              this.path.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case DEST:
            if (field.type == TType.STRUCT) {
              this.dest = new Pathname();
              this.dest.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.path != null) {
        oprot.writeFieldBegin(PATH_FIELD_DESC);
        this.path.write(oprot);
        oprot.writeFieldEnd();
      }
      if (this.dest != null) {
        oprot.writeFieldBegin(DEST_FIELD_DESC);
        this.dest.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("rename_args(");
      boolean first = true;

      sb.append("path:");
      if (this.path == null) {
        sb.append("null");
      } else {
        sb.append(this.path);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("dest:");
      if (this.dest == null) {
        sb.append("null");
      } else {
        sb.append(this.dest);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class rename_result implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("rename_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.BOOL, (short)0);
    private static final TField OUCH_FIELD_DESC = new TField("ouch", TType.STRUCT, (short)1);

    public boolean success;
    public static final int SUCCESS = 0;
    public ThriftIOException ouch;
    public static final int OUCH = 1;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
      public boolean success = false;
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.BOOL)));
      put(OUCH, new FieldMetaData("ouch", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(rename_result.class, metaDataMap);
    }

    public rename_result() {
    }

    public rename_result(
      boolean success,
      ThriftIOException ouch)
    {
      this();
      this.success = success;
      this.__isset.success = true;
      this.ouch = ouch;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public rename_result(rename_result other) {
      __isset.success = other.__isset.success;
      this.success = other.success;
      if (other.isSetOuch()) {
        this.ouch = new ThriftIOException(other.ouch);
      }
    }

    @Override
    public rename_result clone() {
      return new rename_result(this);
    }

    public boolean isSuccess() {
      return this.success;
    }

    public void setSuccess(boolean success) {
      this.success = success;
      this.__isset.success = true;
    }

    public void unsetSuccess() {
      this.__isset.success = false;
    }

    // Returns true if field success is set (has been asigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.__isset.success;
    }

    public void setSuccessIsSet(boolean value) {
      this.__isset.success = value;
    }

    public ThriftIOException getOuch() {
      return this.ouch;
    }

    public void setOuch(ThriftIOException ouch) {
      this.ouch = ouch;
    }

    public void unsetOuch() {
      this.ouch = null;
    }

    // Returns true if field ouch is set (has been asigned a value) and false otherwise
    public boolean isSetOuch() {
      return this.ouch != null;
    }

    public void setOuchIsSet(boolean value) {
      if (!value) {
        this.ouch = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((Boolean)value);
        }
        break;

      case OUCH:
        if (value == null) {
          unsetOuch();
        } else {
          setOuch((ThriftIOException)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return new Boolean(isSuccess());

      case OUCH:
        return getOuch();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case OUCH:
        return isSetOuch();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof rename_result)
        return this.equals((rename_result)that);
      return false;
    }

    public boolean equals(rename_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true;
      boolean that_present_success = true;
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (this.success != that.success)
          return false;
      }

      boolean this_present_ouch = true && this.isSetOuch();
      boolean that_present_ouch = true && that.isSetOuch();
      if (this_present_ouch || that_present_ouch) {
        if (!(this_present_ouch && that_present_ouch))
          return false;
        if (!this.ouch.equals(that.ouch))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case SUCCESS:
            if (field.type == TType.BOOL) {
              this.success = iprot.readBool();
              this.__isset.success = true;
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case OUCH:
            if (field.type == TType.STRUCT) {
              this.ouch = new ThriftIOException();
              this.ouch.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        oprot.writeBool(this.success);
        oprot.writeFieldEnd();
      } else if (this.isSetOuch()) {
        oprot.writeFieldBegin(OUCH_FIELD_DESC);
        this.ouch.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("rename_result(");
      boolean first = true;

      sb.append("success:");
      sb.append(this.success);
      first = false;
      if (!first) sb.append(", ");
      sb.append("ouch:");
      if (this.ouch == null) {
        sb.append("null");
      } else {
        sb.append(this.ouch);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class mkdirs_args implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("mkdirs_args");
    private static final TField PATH_FIELD_DESC = new TField("path", TType.STRUCT, (short)1);

    public Pathname path;
    public static final int PATH = 1;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(PATH, new FieldMetaData("path", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, Pathname.class)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(mkdirs_args.class, metaDataMap);
    }

    public mkdirs_args() {
    }

    public mkdirs_args(
      Pathname path)
    {
      this();
      this.path = path;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public mkdirs_args(mkdirs_args other) {
      if (other.isSetPath()) {
        this.path = new Pathname(other.path);
      }
    }

    @Override
    public mkdirs_args clone() {
      return new mkdirs_args(this);
    }

    public Pathname getPath() {
      return this.path;
    }

    public void setPath(Pathname path) {
      this.path = path;
    }

    public void unsetPath() {
      this.path = null;
    }

    // Returns true if field path is set (has been asigned a value) and false otherwise
    public boolean isSetPath() {
      return this.path != null;
    }

    public void setPathIsSet(boolean value) {
      if (!value) {
        this.path = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case PATH:
        if (value == null) {
          unsetPath();
        } else {
          setPath((Pathname)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case PATH:
        return getPath();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case PATH:
        return isSetPath();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof mkdirs_args)
        return this.equals((mkdirs_args)that);
      return false;
    }

    public boolean equals(mkdirs_args that) {
      if (that == null)
        return false;

      boolean this_present_path = true && this.isSetPath();
      boolean that_present_path = true && that.isSetPath();
      if (this_present_path || that_present_path) {
        if (!(this_present_path && that_present_path))
          return false;
        if (!this.path.equals(that.path))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case PATH:
            if (field.type == TType.STRUCT) {
              this.path = new Pathname();
              this.path.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.path != null) {
        oprot.writeFieldBegin(PATH_FIELD_DESC);
        this.path.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("mkdirs_args(");
      boolean first = true;

      sb.append("path:");
      if (this.path == null) {
        sb.append("null");
      } else {
        sb.append(this.path);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class mkdirs_result implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("mkdirs_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.BOOL, (short)0);
    private static final TField OUCH_FIELD_DESC = new TField("ouch", TType.STRUCT, (short)1);

    public boolean success;
    public static final int SUCCESS = 0;
    public ThriftIOException ouch;
    public static final int OUCH = 1;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
      public boolean success = false;
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.BOOL)));
      put(OUCH, new FieldMetaData("ouch", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(mkdirs_result.class, metaDataMap);
    }

    public mkdirs_result() {
    }

    public mkdirs_result(
      boolean success,
      ThriftIOException ouch)
    {
      this();
      this.success = success;
      this.__isset.success = true;
      this.ouch = ouch;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public mkdirs_result(mkdirs_result other) {
      __isset.success = other.__isset.success;
      this.success = other.success;
      if (other.isSetOuch()) {
        this.ouch = new ThriftIOException(other.ouch);
      }
    }

    @Override
    public mkdirs_result clone() {
      return new mkdirs_result(this);
    }

    public boolean isSuccess() {
      return this.success;
    }

    public void setSuccess(boolean success) {
      this.success = success;
      this.__isset.success = true;
    }

    public void unsetSuccess() {
      this.__isset.success = false;
    }

    // Returns true if field success is set (has been asigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.__isset.success;
    }

    public void setSuccessIsSet(boolean value) {
      this.__isset.success = value;
    }

    public ThriftIOException getOuch() {
      return this.ouch;
    }

    public void setOuch(ThriftIOException ouch) {
      this.ouch = ouch;
    }

    public void unsetOuch() {
      this.ouch = null;
    }

    // Returns true if field ouch is set (has been asigned a value) and false otherwise
    public boolean isSetOuch() {
      return this.ouch != null;
    }

    public void setOuchIsSet(boolean value) {
      if (!value) {
        this.ouch = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((Boolean)value);
        }
        break;

      case OUCH:
        if (value == null) {
          unsetOuch();
        } else {
          setOuch((ThriftIOException)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return new Boolean(isSuccess());

      case OUCH:
        return getOuch();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case OUCH:
        return isSetOuch();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof mkdirs_result)
        return this.equals((mkdirs_result)that);
      return false;
    }

    public boolean equals(mkdirs_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true;
      boolean that_present_success = true;
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (this.success != that.success)
          return false;
      }

      boolean this_present_ouch = true && this.isSetOuch();
      boolean that_present_ouch = true && that.isSetOuch();
      if (this_present_ouch || that_present_ouch) {
        if (!(this_present_ouch && that_present_ouch))
          return false;
        if (!this.ouch.equals(that.ouch))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case SUCCESS:
            if (field.type == TType.BOOL) {
              this.success = iprot.readBool();
              this.__isset.success = true;
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case OUCH:
            if (field.type == TType.STRUCT) {
              this.ouch = new ThriftIOException();
              this.ouch.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        oprot.writeBool(this.success);
        oprot.writeFieldEnd();
      } else if (this.isSetOuch()) {
        oprot.writeFieldBegin(OUCH_FIELD_DESC);
        this.ouch.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("mkdirs_result(");
      boolean first = true;

      sb.append("success:");
      sb.append(this.success);
      first = false;
      if (!first) sb.append(", ");
      sb.append("ouch:");
      if (this.ouch == null) {
        sb.append("null");
      } else {
        sb.append(this.ouch);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class exists_args implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("exists_args");
    private static final TField PATH_FIELD_DESC = new TField("path", TType.STRUCT, (short)1);

    public Pathname path;
    public static final int PATH = 1;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(PATH, new FieldMetaData("path", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, Pathname.class)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(exists_args.class, metaDataMap);
    }

    public exists_args() {
    }

    public exists_args(
      Pathname path)
    {
      this();
      this.path = path;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public exists_args(exists_args other) {
      if (other.isSetPath()) {
        this.path = new Pathname(other.path);
      }
    }

    @Override
    public exists_args clone() {
      return new exists_args(this);
    }

    public Pathname getPath() {
      return this.path;
    }

    public void setPath(Pathname path) {
      this.path = path;
    }

    public void unsetPath() {
      this.path = null;
    }

    // Returns true if field path is set (has been asigned a value) and false otherwise
    public boolean isSetPath() {
      return this.path != null;
    }

    public void setPathIsSet(boolean value) {
      if (!value) {
        this.path = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case PATH:
        if (value == null) {
          unsetPath();
        } else {
          setPath((Pathname)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case PATH:
        return getPath();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case PATH:
        return isSetPath();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof exists_args)
        return this.equals((exists_args)that);
      return false;
    }

    public boolean equals(exists_args that) {
      if (that == null)
        return false;

      boolean this_present_path = true && this.isSetPath();
      boolean that_present_path = true && that.isSetPath();
      if (this_present_path || that_present_path) {
        if (!(this_present_path && that_present_path))
          return false;
        if (!this.path.equals(that.path))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case PATH:
            if (field.type == TType.STRUCT) {
              this.path = new Pathname();
              this.path.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.path != null) {
        oprot.writeFieldBegin(PATH_FIELD_DESC);
        this.path.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("exists_args(");
      boolean first = true;

      sb.append("path:");
      if (this.path == null) {
        sb.append("null");
      } else {
        sb.append(this.path);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class exists_result implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("exists_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.BOOL, (short)0);
    private static final TField OUCH_FIELD_DESC = new TField("ouch", TType.STRUCT, (short)1);

    public boolean success;
    public static final int SUCCESS = 0;
    public ThriftIOException ouch;
    public static final int OUCH = 1;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
      public boolean success = false;
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.BOOL)));
      put(OUCH, new FieldMetaData("ouch", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(exists_result.class, metaDataMap);
    }

    public exists_result() {
    }

    public exists_result(
      boolean success,
      ThriftIOException ouch)
    {
      this();
      this.success = success;
      this.__isset.success = true;
      this.ouch = ouch;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public exists_result(exists_result other) {
      __isset.success = other.__isset.success;
      this.success = other.success;
      if (other.isSetOuch()) {
        this.ouch = new ThriftIOException(other.ouch);
      }
    }

    @Override
    public exists_result clone() {
      return new exists_result(this);
    }

    public boolean isSuccess() {
      return this.success;
    }

    public void setSuccess(boolean success) {
      this.success = success;
      this.__isset.success = true;
    }

    public void unsetSuccess() {
      this.__isset.success = false;
    }

    // Returns true if field success is set (has been asigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.__isset.success;
    }

    public void setSuccessIsSet(boolean value) {
      this.__isset.success = value;
    }

    public ThriftIOException getOuch() {
      return this.ouch;
    }

    public void setOuch(ThriftIOException ouch) {
      this.ouch = ouch;
    }

    public void unsetOuch() {
      this.ouch = null;
    }

    // Returns true if field ouch is set (has been asigned a value) and false otherwise
    public boolean isSetOuch() {
      return this.ouch != null;
    }

    public void setOuchIsSet(boolean value) {
      if (!value) {
        this.ouch = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((Boolean)value);
        }
        break;

      case OUCH:
        if (value == null) {
          unsetOuch();
        } else {
          setOuch((ThriftIOException)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return new Boolean(isSuccess());

      case OUCH:
        return getOuch();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case OUCH:
        return isSetOuch();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof exists_result)
        return this.equals((exists_result)that);
      return false;
    }

    public boolean equals(exists_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true;
      boolean that_present_success = true;
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (this.success != that.success)
          return false;
      }

      boolean this_present_ouch = true && this.isSetOuch();
      boolean that_present_ouch = true && that.isSetOuch();
      if (this_present_ouch || that_present_ouch) {
        if (!(this_present_ouch && that_present_ouch))
          return false;
        if (!this.ouch.equals(that.ouch))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case SUCCESS:
            if (field.type == TType.BOOL) {
              this.success = iprot.readBool();
              this.__isset.success = true;
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case OUCH:
            if (field.type == TType.STRUCT) {
              this.ouch = new ThriftIOException();
              this.ouch.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        oprot.writeBool(this.success);
        oprot.writeFieldEnd();
      } else if (this.isSetOuch()) {
        oprot.writeFieldBegin(OUCH_FIELD_DESC);
        this.ouch.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("exists_result(");
      boolean first = true;

      sb.append("success:");
      sb.append(this.success);
      first = false;
      if (!first) sb.append(", ");
      sb.append("ouch:");
      if (this.ouch == null) {
        sb.append("null");
      } else {
        sb.append(this.ouch);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class stat_args implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("stat_args");
    private static final TField PATH_FIELD_DESC = new TField("path", TType.STRUCT, (short)1);

    public Pathname path;
    public static final int PATH = 1;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(PATH, new FieldMetaData("path", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, Pathname.class)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(stat_args.class, metaDataMap);
    }

    public stat_args() {
    }

    public stat_args(
      Pathname path)
    {
      this();
      this.path = path;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public stat_args(stat_args other) {
      if (other.isSetPath()) {
        this.path = new Pathname(other.path);
      }
    }

    @Override
    public stat_args clone() {
      return new stat_args(this);
    }

    public Pathname getPath() {
      return this.path;
    }

    public void setPath(Pathname path) {
      this.path = path;
    }

    public void unsetPath() {
      this.path = null;
    }

    // Returns true if field path is set (has been asigned a value) and false otherwise
    public boolean isSetPath() {
      return this.path != null;
    }

    public void setPathIsSet(boolean value) {
      if (!value) {
        this.path = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case PATH:
        if (value == null) {
          unsetPath();
        } else {
          setPath((Pathname)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case PATH:
        return getPath();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case PATH:
        return isSetPath();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof stat_args)
        return this.equals((stat_args)that);
      return false;
    }

    public boolean equals(stat_args that) {
      if (that == null)
        return false;

      boolean this_present_path = true && this.isSetPath();
      boolean that_present_path = true && that.isSetPath();
      if (this_present_path || that_present_path) {
        if (!(this_present_path && that_present_path))
          return false;
        if (!this.path.equals(that.path))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case PATH:
            if (field.type == TType.STRUCT) {
              this.path = new Pathname();
              this.path.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.path != null) {
        oprot.writeFieldBegin(PATH_FIELD_DESC);
        this.path.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("stat_args(");
      boolean first = true;

      sb.append("path:");
      if (this.path == null) {
        sb.append("null");
      } else {
        sb.append(this.path);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class stat_result implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("stat_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);
    private static final TField OUCH_FIELD_DESC = new TField("ouch", TType.STRUCT, (short)1);

    public FileStatus success;
    public static final int SUCCESS = 0;
    public ThriftIOException ouch;
    public static final int OUCH = 1;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, FileStatus.class)));
      put(OUCH, new FieldMetaData("ouch", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(stat_result.class, metaDataMap);
    }

    public stat_result() {
    }

    public stat_result(
      FileStatus success,
      ThriftIOException ouch)
    {
      this();
      this.success = success;
      this.ouch = ouch;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public stat_result(stat_result other) {
      if (other.isSetSuccess()) {
        this.success = new FileStatus(other.success);
      }
      if (other.isSetOuch()) {
        this.ouch = new ThriftIOException(other.ouch);
      }
    }

    @Override
    public stat_result clone() {
      return new stat_result(this);
    }

    public FileStatus getSuccess() {
      return this.success;
    }

    public void setSuccess(FileStatus success) {
      this.success = success;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been asigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public ThriftIOException getOuch() {
      return this.ouch;
    }

    public void setOuch(ThriftIOException ouch) {
      this.ouch = ouch;
    }

    public void unsetOuch() {
      this.ouch = null;
    }

    // Returns true if field ouch is set (has been asigned a value) and false otherwise
    public boolean isSetOuch() {
      return this.ouch != null;
    }

    public void setOuchIsSet(boolean value) {
      if (!value) {
        this.ouch = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((FileStatus)value);
        }
        break;

      case OUCH:
        if (value == null) {
          unsetOuch();
        } else {
          setOuch((ThriftIOException)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      case OUCH:
        return getOuch();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case OUCH:
        return isSetOuch();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof stat_result)
        return this.equals((stat_result)that);
      return false;
    }

    public boolean equals(stat_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      boolean this_present_ouch = true && this.isSetOuch();
      boolean that_present_ouch = true && that.isSetOuch();
      if (this_present_ouch || that_present_ouch) {
        if (!(this_present_ouch && that_present_ouch))
          return false;
        if (!this.ouch.equals(that.ouch))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case SUCCESS:
            if (field.type == TType.STRUCT) {
              this.success = new FileStatus();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case OUCH:
            if (field.type == TType.STRUCT) {
              this.ouch = new ThriftIOException();
              this.ouch.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      } else if (this.isSetOuch()) {
        oprot.writeFieldBegin(OUCH_FIELD_DESC);
        this.ouch.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("stat_result(");
      boolean first = true;

      sb.append("success:");
      if (this.success == null) {
        sb.append("null");
      } else {
        sb.append(this.success);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("ouch:");
      if (this.ouch == null) {
        sb.append("null");
      } else {
        sb.append(this.ouch);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class listStatus_args implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("listStatus_args");
    private static final TField PATH_FIELD_DESC = new TField("path", TType.STRUCT, (short)1);

    public Pathname path;
    public static final int PATH = 1;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(PATH, new FieldMetaData("path", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, Pathname.class)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(listStatus_args.class, metaDataMap);
    }

    public listStatus_args() {
    }

    public listStatus_args(
      Pathname path)
    {
      this();
      this.path = path;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public listStatus_args(listStatus_args other) {
      if (other.isSetPath()) {
        this.path = new Pathname(other.path);
      }
    }

    @Override
    public listStatus_args clone() {
      return new listStatus_args(this);
    }

    public Pathname getPath() {
      return this.path;
    }

    public void setPath(Pathname path) {
      this.path = path;
    }

    public void unsetPath() {
      this.path = null;
    }

    // Returns true if field path is set (has been asigned a value) and false otherwise
    public boolean isSetPath() {
      return this.path != null;
    }

    public void setPathIsSet(boolean value) {
      if (!value) {
        this.path = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case PATH:
        if (value == null) {
          unsetPath();
        } else {
          setPath((Pathname)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case PATH:
        return getPath();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case PATH:
        return isSetPath();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof listStatus_args)
        return this.equals((listStatus_args)that);
      return false;
    }

    public boolean equals(listStatus_args that) {
      if (that == null)
        return false;

      boolean this_present_path = true && this.isSetPath();
      boolean that_present_path = true && that.isSetPath();
      if (this_present_path || that_present_path) {
        if (!(this_present_path && that_present_path))
          return false;
        if (!this.path.equals(that.path))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case PATH:
            if (field.type == TType.STRUCT) {
              this.path = new Pathname();
              this.path.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.path != null) {
        oprot.writeFieldBegin(PATH_FIELD_DESC);
        this.path.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("listStatus_args(");
      boolean first = true;

      sb.append("path:");
      if (this.path == null) {
        sb.append("null");
      } else {
        sb.append(this.path);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class listStatus_result implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("listStatus_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.LIST, (short)0);
    private static final TField OUCH_FIELD_DESC = new TField("ouch", TType.STRUCT, (short)1);

    public List<FileStatus> success;
    public static final int SUCCESS = 0;
    public ThriftIOException ouch;
    public static final int OUCH = 1;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new ListMetaData(TType.LIST, 
              new StructMetaData(TType.STRUCT, FileStatus.class))));
      put(OUCH, new FieldMetaData("ouch", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(listStatus_result.class, metaDataMap);
    }

    public listStatus_result() {
    }

    public listStatus_result(
      List<FileStatus> success,
      ThriftIOException ouch)
    {
      this();
      this.success = success;
      this.ouch = ouch;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public listStatus_result(listStatus_result other) {
      if (other.isSetSuccess()) {
        List<FileStatus> __this__success = new ArrayList<FileStatus>();
        for (FileStatus other_element : other.success) {
          __this__success.add(new FileStatus(other_element));
        }
        this.success = __this__success;
      }
      if (other.isSetOuch()) {
        this.ouch = new ThriftIOException(other.ouch);
      }
    }

    @Override
    public listStatus_result clone() {
      return new listStatus_result(this);
    }

    public int getSuccessSize() {
      return (this.success == null) ? 0 : this.success.size();
    }

    public java.util.Iterator<FileStatus> getSuccessIterator() {
      return (this.success == null) ? null : this.success.iterator();
    }

    public void addToSuccess(FileStatus elem) {
      if (this.success == null) {
        this.success = new ArrayList<FileStatus>();
      }
      this.success.add(elem);
    }

    public List<FileStatus> getSuccess() {
      return this.success;
    }

    public void setSuccess(List<FileStatus> success) {
      this.success = success;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been asigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public ThriftIOException getOuch() {
      return this.ouch;
    }

    public void setOuch(ThriftIOException ouch) {
      this.ouch = ouch;
    }

    public void unsetOuch() {
      this.ouch = null;
    }

    // Returns true if field ouch is set (has been asigned a value) and false otherwise
    public boolean isSetOuch() {
      return this.ouch != null;
    }

    public void setOuchIsSet(boolean value) {
      if (!value) {
        this.ouch = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((List<FileStatus>)value);
        }
        break;

      case OUCH:
        if (value == null) {
          unsetOuch();
        } else {
          setOuch((ThriftIOException)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      case OUCH:
        return getOuch();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case OUCH:
        return isSetOuch();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof listStatus_result)
        return this.equals((listStatus_result)that);
      return false;
    }

    public boolean equals(listStatus_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      boolean this_present_ouch = true && this.isSetOuch();
      boolean that_present_ouch = true && that.isSetOuch();
      if (this_present_ouch || that_present_ouch) {
        if (!(this_present_ouch && that_present_ouch))
          return false;
        if (!this.ouch.equals(that.ouch))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case SUCCESS:
            if (field.type == TType.LIST) {
              {
                TList _list8 = iprot.readListBegin();
                this.success = new ArrayList<FileStatus>(_list8.size);
                for (int _i9 = 0; _i9 < _list8.size; ++_i9)
                {
                  FileStatus _elem10;
                  _elem10 = new FileStatus();
                  _elem10.read(iprot);
                  this.success.add(_elem10);
                }
                iprot.readListEnd();
              }
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case OUCH:
            if (field.type == TType.STRUCT) {
              this.ouch = new ThriftIOException();
              this.ouch.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        {
          oprot.writeListBegin(new TList(TType.STRUCT, this.success.size()));
          for (FileStatus _iter11 : this.success)          {
            _iter11.write(oprot);
          }
          oprot.writeListEnd();
        }
        oprot.writeFieldEnd();
      } else if (this.isSetOuch()) {
        oprot.writeFieldBegin(OUCH_FIELD_DESC);
        this.ouch.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("listStatus_result(");
      boolean first = true;

      sb.append("success:");
      if (this.success == null) {
        sb.append("null");
      } else {
        sb.append(this.success);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("ouch:");
      if (this.ouch == null) {
        sb.append("null");
      } else {
        sb.append(this.ouch);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class chmod_args implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("chmod_args");
    private static final TField PATH_FIELD_DESC = new TField("path", TType.STRUCT, (short)1);
    private static final TField MODE_FIELD_DESC = new TField("mode", TType.I16, (short)2);

    public Pathname path;
    public static final int PATH = 1;
    public short mode;
    public static final int MODE = 2;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
      public boolean mode = false;
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(PATH, new FieldMetaData("path", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, Pathname.class)));
      put(MODE, new FieldMetaData("mode", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.I16)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(chmod_args.class, metaDataMap);
    }

    public chmod_args() {
    }

    public chmod_args(
      Pathname path,
      short mode)
    {
      this();
      this.path = path;
      this.mode = mode;
      this.__isset.mode = true;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public chmod_args(chmod_args other) {
      if (other.isSetPath()) {
        this.path = new Pathname(other.path);
      }
      __isset.mode = other.__isset.mode;
      this.mode = other.mode;
    }

    @Override
    public chmod_args clone() {
      return new chmod_args(this);
    }

    public Pathname getPath() {
      return this.path;
    }

    public void setPath(Pathname path) {
      this.path = path;
    }

    public void unsetPath() {
      this.path = null;
    }

    // Returns true if field path is set (has been asigned a value) and false otherwise
    public boolean isSetPath() {
      return this.path != null;
    }

    public void setPathIsSet(boolean value) {
      if (!value) {
        this.path = null;
      }
    }

    public short getMode() {
      return this.mode;
    }

    public void setMode(short mode) {
      this.mode = mode;
      this.__isset.mode = true;
    }

    public void unsetMode() {
      this.__isset.mode = false;
    }

    // Returns true if field mode is set (has been asigned a value) and false otherwise
    public boolean isSetMode() {
      return this.__isset.mode;
    }

    public void setModeIsSet(boolean value) {
      this.__isset.mode = value;
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case PATH:
        if (value == null) {
          unsetPath();
        } else {
          setPath((Pathname)value);
        }
        break;

      case MODE:
        if (value == null) {
          unsetMode();
        } else {
          setMode((Short)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case PATH:
        return getPath();

      case MODE:
        return new Short(getMode());

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case PATH:
        return isSetPath();
      case MODE:
        return isSetMode();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof chmod_args)
        return this.equals((chmod_args)that);
      return false;
    }

    public boolean equals(chmod_args that) {
      if (that == null)
        return false;

      boolean this_present_path = true && this.isSetPath();
      boolean that_present_path = true && that.isSetPath();
      if (this_present_path || that_present_path) {
        if (!(this_present_path && that_present_path))
          return false;
        if (!this.path.equals(that.path))
          return false;
      }

      boolean this_present_mode = true;
      boolean that_present_mode = true;
      if (this_present_mode || that_present_mode) {
        if (!(this_present_mode && that_present_mode))
          return false;
        if (this.mode != that.mode)
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case PATH:
            if (field.type == TType.STRUCT) {
              this.path = new Pathname();
              this.path.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case MODE:
            if (field.type == TType.I16) {
              this.mode = iprot.readI16();
              this.__isset.mode = true;
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.path != null) {
        oprot.writeFieldBegin(PATH_FIELD_DESC);
        this.path.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldBegin(MODE_FIELD_DESC);
      oprot.writeI16(this.mode);
      oprot.writeFieldEnd();
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("chmod_args(");
      boolean first = true;

      sb.append("path:");
      if (this.path == null) {
        sb.append("null");
      } else {
        sb.append(this.path);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("mode:");
      sb.append(this.mode);
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class chmod_result implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("chmod_result");
    private static final TField OUCH_FIELD_DESC = new TField("ouch", TType.STRUCT, (short)1);

    public ThriftIOException ouch;
    public static final int OUCH = 1;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(OUCH, new FieldMetaData("ouch", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(chmod_result.class, metaDataMap);
    }

    public chmod_result() {
    }

    public chmod_result(
      ThriftIOException ouch)
    {
      this();
      this.ouch = ouch;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public chmod_result(chmod_result other) {
      if (other.isSetOuch()) {
        this.ouch = new ThriftIOException(other.ouch);
      }
    }

    @Override
    public chmod_result clone() {
      return new chmod_result(this);
    }

    public ThriftIOException getOuch() {
      return this.ouch;
    }

    public void setOuch(ThriftIOException ouch) {
      this.ouch = ouch;
    }

    public void unsetOuch() {
      this.ouch = null;
    }

    // Returns true if field ouch is set (has been asigned a value) and false otherwise
    public boolean isSetOuch() {
      return this.ouch != null;
    }

    public void setOuchIsSet(boolean value) {
      if (!value) {
        this.ouch = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case OUCH:
        if (value == null) {
          unsetOuch();
        } else {
          setOuch((ThriftIOException)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case OUCH:
        return getOuch();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case OUCH:
        return isSetOuch();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof chmod_result)
        return this.equals((chmod_result)that);
      return false;
    }

    public boolean equals(chmod_result that) {
      if (that == null)
        return false;

      boolean this_present_ouch = true && this.isSetOuch();
      boolean that_present_ouch = true && that.isSetOuch();
      if (this_present_ouch || that_present_ouch) {
        if (!(this_present_ouch && that_present_ouch))
          return false;
        if (!this.ouch.equals(that.ouch))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case OUCH:
            if (field.type == TType.STRUCT) {
              this.ouch = new ThriftIOException();
              this.ouch.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetOuch()) {
        oprot.writeFieldBegin(OUCH_FIELD_DESC);
        this.ouch.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("chmod_result(");
      boolean first = true;

      sb.append("ouch:");
      if (this.ouch == null) {
        sb.append("null");
      } else {
        sb.append(this.ouch);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class chown_args implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("chown_args");
    private static final TField PATH_FIELD_DESC = new TField("path", TType.STRUCT, (short)1);
    private static final TField OWNER_FIELD_DESC = new TField("owner", TType.STRING, (short)2);
    private static final TField GROUP_FIELD_DESC = new TField("group", TType.STRING, (short)3);

    public Pathname path;
    public static final int PATH = 1;
    public String owner;
    public static final int OWNER = 2;
    public String group;
    public static final int GROUP = 3;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(PATH, new FieldMetaData("path", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, Pathname.class)));
      put(OWNER, new FieldMetaData("owner", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      put(GROUP, new FieldMetaData("group", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(chown_args.class, metaDataMap);
    }

    public chown_args() {
    }

    public chown_args(
      Pathname path,
      String owner,
      String group)
    {
      this();
      this.path = path;
      this.owner = owner;
      this.group = group;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public chown_args(chown_args other) {
      if (other.isSetPath()) {
        this.path = new Pathname(other.path);
      }
      if (other.isSetOwner()) {
        this.owner = other.owner;
      }
      if (other.isSetGroup()) {
        this.group = other.group;
      }
    }

    @Override
    public chown_args clone() {
      return new chown_args(this);
    }

    public Pathname getPath() {
      return this.path;
    }

    public void setPath(Pathname path) {
      this.path = path;
    }

    public void unsetPath() {
      this.path = null;
    }

    // Returns true if field path is set (has been asigned a value) and false otherwise
    public boolean isSetPath() {
      return this.path != null;
    }

    public void setPathIsSet(boolean value) {
      if (!value) {
        this.path = null;
      }
    }

    public String getOwner() {
      return this.owner;
    }

    public void setOwner(String owner) {
      this.owner = owner;
    }

    public void unsetOwner() {
      this.owner = null;
    }

    // Returns true if field owner is set (has been asigned a value) and false otherwise
    public boolean isSetOwner() {
      return this.owner != null;
    }

    public void setOwnerIsSet(boolean value) {
      if (!value) {
        this.owner = null;
      }
    }

    public String getGroup() {
      return this.group;
    }

    public void setGroup(String group) {
      this.group = group;
    }

    public void unsetGroup() {
      this.group = null;
    }

    // Returns true if field group is set (has been asigned a value) and false otherwise
    public boolean isSetGroup() {
      return this.group != null;
    }

    public void setGroupIsSet(boolean value) {
      if (!value) {
        this.group = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case PATH:
        if (value == null) {
          unsetPath();
        } else {
          setPath((Pathname)value);
        }
        break;

      case OWNER:
        if (value == null) {
          unsetOwner();
        } else {
          setOwner((String)value);
        }
        break;

      case GROUP:
        if (value == null) {
          unsetGroup();
        } else {
          setGroup((String)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case PATH:
        return getPath();

      case OWNER:
        return getOwner();

      case GROUP:
        return getGroup();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case PATH:
        return isSetPath();
      case OWNER:
        return isSetOwner();
      case GROUP:
        return isSetGroup();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof chown_args)
        return this.equals((chown_args)that);
      return false;
    }

    public boolean equals(chown_args that) {
      if (that == null)
        return false;

      boolean this_present_path = true && this.isSetPath();
      boolean that_present_path = true && that.isSetPath();
      if (this_present_path || that_present_path) {
        if (!(this_present_path && that_present_path))
          return false;
        if (!this.path.equals(that.path))
          return false;
      }

      boolean this_present_owner = true && this.isSetOwner();
      boolean that_present_owner = true && that.isSetOwner();
      if (this_present_owner || that_present_owner) {
        if (!(this_present_owner && that_present_owner))
          return false;
        if (!this.owner.equals(that.owner))
          return false;
      }

      boolean this_present_group = true && this.isSetGroup();
      boolean that_present_group = true && that.isSetGroup();
      if (this_present_group || that_present_group) {
        if (!(this_present_group && that_present_group))
          return false;
        if (!this.group.equals(that.group))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case PATH:
            if (field.type == TType.STRUCT) {
              this.path = new Pathname();
              this.path.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case OWNER:
            if (field.type == TType.STRING) {
              this.owner = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case GROUP:
            if (field.type == TType.STRING) {
              this.group = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.path != null) {
        oprot.writeFieldBegin(PATH_FIELD_DESC);
        this.path.write(oprot);
        oprot.writeFieldEnd();
      }
      if (this.owner != null) {
        oprot.writeFieldBegin(OWNER_FIELD_DESC);
        oprot.writeString(this.owner);
        oprot.writeFieldEnd();
      }
      if (this.group != null) {
        oprot.writeFieldBegin(GROUP_FIELD_DESC);
        oprot.writeString(this.group);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("chown_args(");
      boolean first = true;

      sb.append("path:");
      if (this.path == null) {
        sb.append("null");
      } else {
        sb.append(this.path);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("owner:");
      if (this.owner == null) {
        sb.append("null");
      } else {
        sb.append(this.owner);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("group:");
      if (this.group == null) {
        sb.append("null");
      } else {
        sb.append(this.group);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class chown_result implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("chown_result");
    private static final TField OUCH_FIELD_DESC = new TField("ouch", TType.STRUCT, (short)1);

    public ThriftIOException ouch;
    public static final int OUCH = 1;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(OUCH, new FieldMetaData("ouch", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(chown_result.class, metaDataMap);
    }

    public chown_result() {
    }

    public chown_result(
      ThriftIOException ouch)
    {
      this();
      this.ouch = ouch;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public chown_result(chown_result other) {
      if (other.isSetOuch()) {
        this.ouch = new ThriftIOException(other.ouch);
      }
    }

    @Override
    public chown_result clone() {
      return new chown_result(this);
    }

    public ThriftIOException getOuch() {
      return this.ouch;
    }

    public void setOuch(ThriftIOException ouch) {
      this.ouch = ouch;
    }

    public void unsetOuch() {
      this.ouch = null;
    }

    // Returns true if field ouch is set (has been asigned a value) and false otherwise
    public boolean isSetOuch() {
      return this.ouch != null;
    }

    public void setOuchIsSet(boolean value) {
      if (!value) {
        this.ouch = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case OUCH:
        if (value == null) {
          unsetOuch();
        } else {
          setOuch((ThriftIOException)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case OUCH:
        return getOuch();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case OUCH:
        return isSetOuch();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof chown_result)
        return this.equals((chown_result)that);
      return false;
    }

    public boolean equals(chown_result that) {
      if (that == null)
        return false;

      boolean this_present_ouch = true && this.isSetOuch();
      boolean that_present_ouch = true && that.isSetOuch();
      if (this_present_ouch || that_present_ouch) {
        if (!(this_present_ouch && that_present_ouch))
          return false;
        if (!this.ouch.equals(that.ouch))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case OUCH:
            if (field.type == TType.STRUCT) {
              this.ouch = new ThriftIOException();
              this.ouch.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetOuch()) {
        oprot.writeFieldBegin(OUCH_FIELD_DESC);
        this.ouch.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("chown_result(");
      boolean first = true;

      sb.append("ouch:");
      if (this.ouch == null) {
        sb.append("null");
      } else {
        sb.append(this.ouch);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class setReplication_args implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("setReplication_args");
    private static final TField PATH_FIELD_DESC = new TField("path", TType.STRUCT, (short)1);
    private static final TField REPLICATION_FIELD_DESC = new TField("replication", TType.I16, (short)2);

    public Pathname path;
    public static final int PATH = 1;
    public short replication;
    public static final int REPLICATION = 2;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
      public boolean replication = false;
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(PATH, new FieldMetaData("path", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, Pathname.class)));
      put(REPLICATION, new FieldMetaData("replication", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.I16)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(setReplication_args.class, metaDataMap);
    }

    public setReplication_args() {
    }

    public setReplication_args(
      Pathname path,
      short replication)
    {
      this();
      this.path = path;
      this.replication = replication;
      this.__isset.replication = true;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public setReplication_args(setReplication_args other) {
      if (other.isSetPath()) {
        this.path = new Pathname(other.path);
      }
      __isset.replication = other.__isset.replication;
      this.replication = other.replication;
    }

    @Override
    public setReplication_args clone() {
      return new setReplication_args(this);
    }

    public Pathname getPath() {
      return this.path;
    }

    public void setPath(Pathname path) {
      this.path = path;
    }

    public void unsetPath() {
      this.path = null;
    }

    // Returns true if field path is set (has been asigned a value) and false otherwise
    public boolean isSetPath() {
      return this.path != null;
    }

    public void setPathIsSet(boolean value) {
      if (!value) {
        this.path = null;
      }
    }

    public short getReplication() {
      return this.replication;
    }

    public void setReplication(short replication) {
      this.replication = replication;
      this.__isset.replication = true;
    }

    public void unsetReplication() {
      this.__isset.replication = false;
    }

    // Returns true if field replication is set (has been asigned a value) and false otherwise
    public boolean isSetReplication() {
      return this.__isset.replication;
    }

    public void setReplicationIsSet(boolean value) {
      this.__isset.replication = value;
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case PATH:
        if (value == null) {
          unsetPath();
        } else {
          setPath((Pathname)value);
        }
        break;

      case REPLICATION:
        if (value == null) {
          unsetReplication();
        } else {
          setReplication((Short)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case PATH:
        return getPath();

      case REPLICATION:
        return new Short(getReplication());

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case PATH:
        return isSetPath();
      case REPLICATION:
        return isSetReplication();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof setReplication_args)
        return this.equals((setReplication_args)that);
      return false;
    }

    public boolean equals(setReplication_args that) {
      if (that == null)
        return false;

      boolean this_present_path = true && this.isSetPath();
      boolean that_present_path = true && that.isSetPath();
      if (this_present_path || that_present_path) {
        if (!(this_present_path && that_present_path))
          return false;
        if (!this.path.equals(that.path))
          return false;
      }

      boolean this_present_replication = true;
      boolean that_present_replication = true;
      if (this_present_replication || that_present_replication) {
        if (!(this_present_replication && that_present_replication))
          return false;
        if (this.replication != that.replication)
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case PATH:
            if (field.type == TType.STRUCT) {
              this.path = new Pathname();
              this.path.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case REPLICATION:
            if (field.type == TType.I16) {
              this.replication = iprot.readI16();
              this.__isset.replication = true;
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.path != null) {
        oprot.writeFieldBegin(PATH_FIELD_DESC);
        this.path.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldBegin(REPLICATION_FIELD_DESC);
      oprot.writeI16(this.replication);
      oprot.writeFieldEnd();
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("setReplication_args(");
      boolean first = true;

      sb.append("path:");
      if (this.path == null) {
        sb.append("null");
      } else {
        sb.append(this.path);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("replication:");
      sb.append(this.replication);
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class setReplication_result implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("setReplication_result");
    private static final TField OUCH_FIELD_DESC = new TField("ouch", TType.STRUCT, (short)1);

    public ThriftIOException ouch;
    public static final int OUCH = 1;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(OUCH, new FieldMetaData("ouch", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(setReplication_result.class, metaDataMap);
    }

    public setReplication_result() {
    }

    public setReplication_result(
      ThriftIOException ouch)
    {
      this();
      this.ouch = ouch;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public setReplication_result(setReplication_result other) {
      if (other.isSetOuch()) {
        this.ouch = new ThriftIOException(other.ouch);
      }
    }

    @Override
    public setReplication_result clone() {
      return new setReplication_result(this);
    }

    public ThriftIOException getOuch() {
      return this.ouch;
    }

    public void setOuch(ThriftIOException ouch) {
      this.ouch = ouch;
    }

    public void unsetOuch() {
      this.ouch = null;
    }

    // Returns true if field ouch is set (has been asigned a value) and false otherwise
    public boolean isSetOuch() {
      return this.ouch != null;
    }

    public void setOuchIsSet(boolean value) {
      if (!value) {
        this.ouch = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case OUCH:
        if (value == null) {
          unsetOuch();
        } else {
          setOuch((ThriftIOException)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case OUCH:
        return getOuch();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case OUCH:
        return isSetOuch();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof setReplication_result)
        return this.equals((setReplication_result)that);
      return false;
    }

    public boolean equals(setReplication_result that) {
      if (that == null)
        return false;

      boolean this_present_ouch = true && this.isSetOuch();
      boolean that_present_ouch = true && that.isSetOuch();
      if (this_present_ouch || that_present_ouch) {
        if (!(this_present_ouch && that_present_ouch))
          return false;
        if (!this.ouch.equals(that.ouch))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case OUCH:
            if (field.type == TType.STRUCT) {
              this.ouch = new ThriftIOException();
              this.ouch.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetOuch()) {
        oprot.writeFieldBegin(OUCH_FIELD_DESC);
        this.ouch.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("setReplication_result(");
      boolean first = true;

      sb.append("ouch:");
      if (this.ouch == null) {
        sb.append("null");
      } else {
        sb.append(this.ouch);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class getFileBlockLocations_args implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("getFileBlockLocations_args");
    private static final TField PATH_FIELD_DESC = new TField("path", TType.STRUCT, (short)1);
    private static final TField START_FIELD_DESC = new TField("start", TType.I64, (short)2);
    private static final TField LENGTH_FIELD_DESC = new TField("length", TType.I64, (short)3);

    public Pathname path;
    public static final int PATH = 1;
    public long start;
    public static final int START = 2;
    public long length;
    public static final int LENGTH = 3;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
      public boolean start = false;
      public boolean length = false;
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(PATH, new FieldMetaData("path", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, Pathname.class)));
      put(START, new FieldMetaData("start", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.I64)));
      put(LENGTH, new FieldMetaData("length", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.I64)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(getFileBlockLocations_args.class, metaDataMap);
    }

    public getFileBlockLocations_args() {
    }

    public getFileBlockLocations_args(
      Pathname path,
      long start,
      long length)
    {
      this();
      this.path = path;
      this.start = start;
      this.__isset.start = true;
      this.length = length;
      this.__isset.length = true;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getFileBlockLocations_args(getFileBlockLocations_args other) {
      if (other.isSetPath()) {
        this.path = new Pathname(other.path);
      }
      __isset.start = other.__isset.start;
      this.start = other.start;
      __isset.length = other.__isset.length;
      this.length = other.length;
    }

    @Override
    public getFileBlockLocations_args clone() {
      return new getFileBlockLocations_args(this);
    }

    public Pathname getPath() {
      return this.path;
    }

    public void setPath(Pathname path) {
      this.path = path;
    }

    public void unsetPath() {
      this.path = null;
    }

    // Returns true if field path is set (has been asigned a value) and false otherwise
    public boolean isSetPath() {
      return this.path != null;
    }

    public void setPathIsSet(boolean value) {
      if (!value) {
        this.path = null;
      }
    }

    public long getStart() {
      return this.start;
    }

    public void setStart(long start) {
      this.start = start;
      this.__isset.start = true;
    }

    public void unsetStart() {
      this.__isset.start = false;
    }

    // Returns true if field start is set (has been asigned a value) and false otherwise
    public boolean isSetStart() {
      return this.__isset.start;
    }

    public void setStartIsSet(boolean value) {
      this.__isset.start = value;
    }

    public long getLength() {
      return this.length;
    }

    public void setLength(long length) {
      this.length = length;
      this.__isset.length = true;
    }

    public void unsetLength() {
      this.__isset.length = false;
    }

    // Returns true if field length is set (has been asigned a value) and false otherwise
    public boolean isSetLength() {
      return this.__isset.length;
    }

    public void setLengthIsSet(boolean value) {
      this.__isset.length = value;
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case PATH:
        if (value == null) {
          unsetPath();
        } else {
          setPath((Pathname)value);
        }
        break;

      case START:
        if (value == null) {
          unsetStart();
        } else {
          setStart((Long)value);
        }
        break;

      case LENGTH:
        if (value == null) {
          unsetLength();
        } else {
          setLength((Long)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case PATH:
        return getPath();

      case START:
        return new Long(getStart());

      case LENGTH:
        return new Long(getLength());

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case PATH:
        return isSetPath();
      case START:
        return isSetStart();
      case LENGTH:
        return isSetLength();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof getFileBlockLocations_args)
        return this.equals((getFileBlockLocations_args)that);
      return false;
    }

    public boolean equals(getFileBlockLocations_args that) {
      if (that == null)
        return false;

      boolean this_present_path = true && this.isSetPath();
      boolean that_present_path = true && that.isSetPath();
      if (this_present_path || that_present_path) {
        if (!(this_present_path && that_present_path))
          return false;
        if (!this.path.equals(that.path))
          return false;
      }

      boolean this_present_start = true;
      boolean that_present_start = true;
      if (this_present_start || that_present_start) {
        if (!(this_present_start && that_present_start))
          return false;
        if (this.start != that.start)
          return false;
      }

      boolean this_present_length = true;
      boolean that_present_length = true;
      if (this_present_length || that_present_length) {
        if (!(this_present_length && that_present_length))
          return false;
        if (this.length != that.length)
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case PATH:
            if (field.type == TType.STRUCT) {
              this.path = new Pathname();
              this.path.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case START:
            if (field.type == TType.I64) {
              this.start = iprot.readI64();
              this.__isset.start = true;
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case LENGTH:
            if (field.type == TType.I64) {
              this.length = iprot.readI64();
              this.__isset.length = true;
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.path != null) {
        oprot.writeFieldBegin(PATH_FIELD_DESC);
        this.path.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldBegin(START_FIELD_DESC);
      oprot.writeI64(this.start);
      oprot.writeFieldEnd();
      oprot.writeFieldBegin(LENGTH_FIELD_DESC);
      oprot.writeI64(this.length);
      oprot.writeFieldEnd();
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("getFileBlockLocations_args(");
      boolean first = true;

      sb.append("path:");
      if (this.path == null) {
        sb.append("null");
      } else {
        sb.append(this.path);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("start:");
      sb.append(this.start);
      first = false;
      if (!first) sb.append(", ");
      sb.append("length:");
      sb.append(this.length);
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class getFileBlockLocations_result implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("getFileBlockLocations_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.LIST, (short)0);
    private static final TField OUCH_FIELD_DESC = new TField("ouch", TType.STRUCT, (short)1);

    public List<BlockLocation> success;
    public static final int SUCCESS = 0;
    public ThriftIOException ouch;
    public static final int OUCH = 1;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new ListMetaData(TType.LIST, 
              new StructMetaData(TType.STRUCT, BlockLocation.class))));
      put(OUCH, new FieldMetaData("ouch", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(getFileBlockLocations_result.class, metaDataMap);
    }

    public getFileBlockLocations_result() {
    }

    public getFileBlockLocations_result(
      List<BlockLocation> success,
      ThriftIOException ouch)
    {
      this();
      this.success = success;
      this.ouch = ouch;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getFileBlockLocations_result(getFileBlockLocations_result other) {
      if (other.isSetSuccess()) {
        List<BlockLocation> __this__success = new ArrayList<BlockLocation>();
        for (BlockLocation other_element : other.success) {
          __this__success.add(new BlockLocation(other_element));
        }
        this.success = __this__success;
      }
      if (other.isSetOuch()) {
        this.ouch = new ThriftIOException(other.ouch);
      }
    }

    @Override
    public getFileBlockLocations_result clone() {
      return new getFileBlockLocations_result(this);
    }

    public int getSuccessSize() {
      return (this.success == null) ? 0 : this.success.size();
    }

    public java.util.Iterator<BlockLocation> getSuccessIterator() {
      return (this.success == null) ? null : this.success.iterator();
    }

    public void addToSuccess(BlockLocation elem) {
      if (this.success == null) {
        this.success = new ArrayList<BlockLocation>();
      }
      this.success.add(elem);
    }

    public List<BlockLocation> getSuccess() {
      return this.success;
    }

    public void setSuccess(List<BlockLocation> success) {
      this.success = success;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been asigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public ThriftIOException getOuch() {
      return this.ouch;
    }

    public void setOuch(ThriftIOException ouch) {
      this.ouch = ouch;
    }

    public void unsetOuch() {
      this.ouch = null;
    }

    // Returns true if field ouch is set (has been asigned a value) and false otherwise
    public boolean isSetOuch() {
      return this.ouch != null;
    }

    public void setOuchIsSet(boolean value) {
      if (!value) {
        this.ouch = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((List<BlockLocation>)value);
        }
        break;

      case OUCH:
        if (value == null) {
          unsetOuch();
        } else {
          setOuch((ThriftIOException)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      case OUCH:
        return getOuch();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case OUCH:
        return isSetOuch();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof getFileBlockLocations_result)
        return this.equals((getFileBlockLocations_result)that);
      return false;
    }

    public boolean equals(getFileBlockLocations_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      boolean this_present_ouch = true && this.isSetOuch();
      boolean that_present_ouch = true && that.isSetOuch();
      if (this_present_ouch || that_present_ouch) {
        if (!(this_present_ouch && that_present_ouch))
          return false;
        if (!this.ouch.equals(that.ouch))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case SUCCESS:
            if (field.type == TType.LIST) {
              {
                TList _list12 = iprot.readListBegin();
                this.success = new ArrayList<BlockLocation>(_list12.size);
                for (int _i13 = 0; _i13 < _list12.size; ++_i13)
                {
                  BlockLocation _elem14;
                  _elem14 = new BlockLocation();
                  _elem14.read(iprot);
                  this.success.add(_elem14);
                }
                iprot.readListEnd();
              }
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case OUCH:
            if (field.type == TType.STRUCT) {
              this.ouch = new ThriftIOException();
              this.ouch.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        {
          oprot.writeListBegin(new TList(TType.STRUCT, this.success.size()));
          for (BlockLocation _iter15 : this.success)          {
            _iter15.write(oprot);
          }
          oprot.writeListEnd();
        }
        oprot.writeFieldEnd();
      } else if (this.isSetOuch()) {
        oprot.writeFieldBegin(OUCH_FIELD_DESC);
        this.ouch.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("getFileBlockLocations_result(");
      boolean first = true;

      sb.append("success:");
      if (this.success == null) {
        sb.append("null");
      } else {
        sb.append(this.success);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("ouch:");
      if (this.ouch == null) {
        sb.append("null");
      } else {
        sb.append(this.ouch);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

}
